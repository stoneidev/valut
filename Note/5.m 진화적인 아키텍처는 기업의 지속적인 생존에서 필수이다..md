Evolutionary architecture consists of broad areas of inquiry: mechanics and structure.

The mechanics of evolutionary architecture concern the engineering practices and verification that allow an architecture to evolve, which overlap architectural governance. [[5.m 진화적인 아키텍처는 기업의 지속적인 생존에서 필수이다.#^ae12ea|PART 1]]

The other aspect of Building Evolutionary Architectures concerns the structure or topology of software systems. [[5.m 진화적인 아키텍처는 기업의 지속적인 생존에서 필수이다.#^f4c74f|PART 2]]

Many of the facets of building evolutionary architectures combine both mechanics and structure; Part III of the book is titled “Impact.” It includes many case studies, provides advice, and covers patterns and antipatterns as well as other considerations architects and teams need to be aware of to make evolution possible. [[5.m 진화적인 아키텍처는 기업의 지속적인 생존에서 필수이다.#^8ab233|PART 3]]
# PART 1.  Mechanics

^ae12ea

## 1. Evolving Software Architecture
### 1.1 진화적 소프트웨어의 과제

>bit rot: also known as software rot, code rot, software erosion, software decay, or software entropy, is either a slow deterioration of software quality over time or its diminishing responsiveness that will eventually lead to software becoming faulty.

소프트웨어의 품질을 유지하기 어려운 이유는 두 가지다. 복잡한 소프트웨어의 다양한 작동부를 전체적으로 관리하기 쉽지 않고, 개발 생태계는 항상 역동적으로 변화하기 때문이다. 소프트웨어 개발 생태계는 새로운 형식이나 관행이 등장해 현재 상태를 뒤흔들고 새로운 균형을 잡도록 종용한다. 비유하자면, 외발자전거 선수에게 계속해서 상자를 건네며 균형을 유지하도록 강요하고 있는 셈이다. ^d9aeea

소프트웨어 개발 생태계는 끊임없이 진화하면 아키텍처를 대하는 새로운 접근 방식들을 낳고 있다. 그리고 이 혁신이 이루어지는 과정은 매우 유기적이다 새로운 기술은 끊임없이 생태계 안에서 등장하며 다른 신기능과 기존 기능을 결합하는 통로를 연다.

특정 문제를 해결하기 위한 구조 설계는 아키텍트의 주요 업무 중 하나다. 해결할 문제가 있고, 소프트웨어를 통해 이를 해결하기로 결정한 경우에 해당한다. 구조 설계를 시작할 때는 여러 요소를 도메인과 아키텍쳐 특성이라는 두 영역으로 나누어서 생각해야 한다. 
### 1.2 진화적 아키텍처

아키텍처의 진화 메커니즘과 아키텍트가 내리는 모든 결정은 다음 정의로부터 파생된다.

> 진화적 소프트웨어 아키텍처는 여러 차원에 걸쳐 유도된 변화와 점진적 변화를 지원한다. 
> An evolutionary software architecture supports guided, incremental change across multiple dimensions.

#### 1.2.1 유도된 변화(Guided Change)
아키텍처의 핵심 특성을 선정하고 나면 해당 특성을 보호하는 방향으로 아키텍처가 변화하도록 유도해야 한다. 이를 위해 피트니스 함수라는 진화적 컴퓨팅 개념을 차용할 것이다. 피트니스 함수는 변형 알고리즘이 생성될 때마다 알고리즘 설계자가 정의한 '적합성'에 근거해 각 변형이 얼마나 '적합한가'를 판단한다. 

진화적 아키텍처의 목표도 이와 비슷하다. 아키텍처의 진화에 따른 변화가 아키텍처의 핵심 특성에 어떤 영향을 미치는지 평가하고, 시간이 지남에 따라 이러한 특성이 저하되지 않도록 방지할 매커니즘이 필요하다. 진화적 아키텍처는 소프트웨어 개발을 대하는 도를 넘는, 무분별한 접근 방식이 아니다. 그보다는, 빠른 변화의 필요성과 아키텍처 특성의 엄밀함 사이에 균형을 가져오는 개념에 가깝다. 피트니스 함수는 아키텍처 의사 결정을 주도하며, 변화하는 비즈니스 및 기술 환경에 대응할 수 있도록 아키텍처의 변화를 유도한다. 

#### 1.2.2 점진적 변화
점진적 변화는 소프트웨어 아키텍처의 두 측면, 소프트웨어의 점진적 빌드와 배포 방법을 나타낸다. 점진적 변화를 성공적으로 이끌기 위해서는 지속적 배포 관행들을 다양하게 조율해야 한다. 모든 관행을 항상 동시에 적용해야 하는 것은 아니지만, 현업에서는 그런 상황이 자주 발생한다. 

#### 1.2.3 다중 아키텍쳐 차원(Multiple Architectural Dimensions)
진화 가능한 아키텍처를 설계하려는 아키텍트는 변화의 영향이 미치는 시스템 요소의 모든 상호 연결 관계를 고려해야 한다. 모든 존재가 서로 상대적이라는 것이 물리학을 배운 사람에게 당연한 이치이듯, 모든 아키텍트는 소프트웨어 프로젝트에 여러 차원이 존재한다는 것을 알고 있다. 

진화 가능한 소프트웨어 시스템을 구축하기 위해, 아키텍트의 사고는 아키텍처의 기술적인 영역 너머의 지점에 닿은 수 있어야 한다. 가령 프로젝트에 관계형 데이터베이스가 포함되어 있다면 데이터베이스 엔티티의 구조와 관계도 시간이 지남에 따라 진화할 것이다. 또한 시스템이 진화하는 과정에서 보안 취약점을 노출해서도 안 된다. 이러한 사안들은 모두 아키텍처를 이루는 차원의 일종이다. 모든 프로젝트에는 차원이 존재하며 아키텍트 담당자는 진화의 관점에서 이를 반드시 고려해야 한다. 다음은 현대 소프트웨어 아키텍처에서 일반적으로 진화성에 영향을 미친다고 여기는 차원들이다. 

- 기술 : 아키텍처의 구현부, 프레임워크, 의존 라이브러리, 구현 언어 등
- 데이터 : 데이터베이스 스키마, 테이블 레이아웃, 최적화 등. 일반적으로 데이터베이스 관리자가 담당하는 유형의 아키텍쳐
- 보안 : 보안 정책과 지침 정으, 결함 조사 도구 선정
- 운영/시스템 : 기존의 물리/가상 인프라(서버, 머신 클러스터, 스위치, 클라우드 리소스 등)와 아키텍처를 매핑하는 방식 결정

	![[Screenshot 2024-02-06 at 9.45.58 PM.png]]

진화적 아키텍처는 아키텍트의 고민거리를 덜어준다. 현대의 소프트웨어 개발 생태계에 몸담고 있는 대부분의 아키텍트는 두 가지 궁금증을 갖기 마련이다. ==매 순간 모든 것이 변하는 세계에서 어떻게 장기적인 계획을 세울 수 있는가?== 또는 ==아키텍처를 구축한 뒤 시간의 흐름에 따른 질적 저하를 막으려면 어떻게 해야 하는가? ==
### 1.3 상시 변화하는 환경의 장기 계획 수립 가능성
결론적으로 우리는 기술 환경의 변화를 기정사실화하고 시스템을 설계해야 한다.  엔터프라이즈 아키텍트와 개발자는 새로운 환경에 적응해야 한다. 전통적인 개발 환경에서 장기 계획을 수립했던 관행의 이면에는 소프트웨어 변경 비용이 배우 높다고 여겼던 재정적인 동기가 있다. 그러나 현대의 엔지니어링 관행을 프로세스 자동화와 데브옵스 기술의 발전을 통해 소프트웨어 변경 비용을 낮춤으로써 기존의 전제를 무효로 만든다.  

아키텍처에 진화성이 더해지는 순간, 완전히 새로운 행동 양식이 등장하며 동적 균형을 다시금 무너뜨리게 된다. 

### 1.4 시간에 따른 아키텍처의 성능 저하 방지
흔히 비트 부패라 불리는 현상은 많은 조직에서 발생한다. 아키텍트는 비즈니스 요구사항과 "~성"에 맞추어 아키텍처 패턴을 선택하지만 시간이 지남에 따라 이러한 특성은 의도하지 않게 저하되는 경우가 많다. 이런 일들이 일어나지 않도록 보호 하려면 어떤 조치를 취해야 할까? ==진화성을 아키텍처 특성으로 추가한다는 것은 시스템이 진화하며 나머지 특성을 보호한다는 의미다.== 진화성은 다른 모든 아키텍처 특성을 보호하는 메타적 성격을 띤 아키텍쳐 래퍼다. 아키텍처 거버넌스는 설계, 품질, 보안 등의 요소로 정의한다. 이 책은 지화적 아키텍처의 관점에서 아키텍처 거버넌스를 자동화하는 다양한 기법을 설명한다. 

### 1.5 왜 진화인가?
진화적 아키텍처의 정의는 점진적 아키텍처, 유도된 아키텍처라는 두 가지 핵심 특성을 동시에 포함한다. 진화라는 단어를 선호하는 이유는, 점층적인 불가해함과 우발적인 복잡성을 덧대고 받아들인 아키텍처가 아닌, 근본적 진화가 유발하는 변화에 순응하는 아키덱처에 관심을 두기 때문이다. 

==애자일 아키텍처의 목표는 아키텍처의 부재 자체가 아니라 소프트웨어 개발 과정에 존재하는 무가치한 관료적 행태를 배제하는 것이다.==  매우 단순한 시스템을 구축할 때는 아키텍처의 고려 사안들에 크게 신경을 쓸 필요가 없다. 그러나 정교한 시스템은 목적에 부합하는 설계와 함께 정확한 출발점이 필요하다. 

장기적인 목표를 뒷받침할 만한 구조와 거버넌스를 확보하는 것, 또한 이들이 불필요한 형식과 저항을 낳지 않을 정도로 제한하는 것, 이 두 조건 사이에 균형을 유지하는 것이 바로 진화적 아키텍처의 핵심이다. 
## 2. Fitness Function

개발자와 아키텍트가 진화적 시스템을 구축하는 기법과 도구는 진화적 아키텍처 역학에서 다루는 주제다. ==피트니스 함수는 그중에서도 특히 중요한 보호 매커니즘이다. 아키텍처에서 피트니스 함수의 역할은 애플리케이션 도메인에서 단위 테스트가 담당하는 역할과 동등하다. ==

> An evolutionary architecture supports guided, incremental change across multiple dimensions.

위 정의에 언급된 유도(guided)라는 단어는, 아키텍처가 지향하거나 표명해야 할 일정한 목표가 존재함을 나타낸다. 

### 2.1 정의

아키텍처 관점에서 피트니스 함수를 정의하기 위해 진화적 컴퓨팅 분야에서 해당 개념을 차용해보자. 

> 아키텍처 피트니스 함수는 아키텍처 특성에 대해 객관적인 무결성 평가를 내릴 수 있는 모든 메커니즘을 일컫는다. 

아키턱처 피트니스 함수는 진화적 아키텍처를 구현하는 기본 매커니즘을 형성한다. ==단위 테스트의 대상이 도메인이라면 피트니스 함수의 대상은 아키텍처 특성이다. ==이러한 아키텍처 특성을 한번에 다양한 방식으로 검증할 수 있는 단일 도구는 없다. 대신, 피트니스 함수는 자신의 생태계 여러 부분에 다양한 도구를 접목한다. 이러한 도구의 종류는 팀이 관리하는 아키텍처의 특성에 따라 다르다.

	![[Screenshot 2024-02-06 at 10.19.11 PM.png]]

아키텍트는 위에서 보이듯 다양한 도구를 사용해 피트니스 함수를 정의할 수 있다.

- 모니터 : 모니터링은 데브옵스 및 운영 도구이며 성능, 확장성 등을 확인하는 수단이다. 
- 코드 메트릭 : 아키텍트는 다누이 테스트에 메트릭을 비롯한 여러 검증 절차를 추가할 수 있다. 이를 통해 아키텍처의 다양한 고려 사항과 설계 요소의 유효성을 검사할 수 있다. 
- 카오스 엔지니어링 : 비교적 최근 개발된 엔지니어링 기법으로, 원격 환경에 인위적으로 결함을 주입하고 스트레스를 가한다. 팀은 이 결과를 바탕으로 시스템의 복원력을 구축한다. 
- 아키텍처 테스트 프레임워크 : 근래에는 아키텍처 구조 테스트 전용 프레임워크가 등장하였으며, 다양한 검증 절차를 자동화된 테스트 형태로 아키텍트가 직접 가공할 수 있다. 
- 보안 스캐닝 : 관할 부서가 따로 있다 해도 보안은 아키텍트의 설계와 선택에 영향을 미친다. 따라서 보안은 언제나 아키텍트의 관심사일 수밖에 없다. 

진화적 아키텍처가 피트니스 함수에 의해 유도된다함은, 아키텍처 선택 사항 각각을 단일 또는 시스템 전체의 피트니스 함수를 통해 평가한다는 뜻이다. 결국 이러한 평가는 변화의 영향력을 반영한다. 피트니스 함수는 해당 아키텍처에서 중요한 것이 무엇인가에 대한 총체적 정의이며, 소프트웨어 시스템 개발 과정에서 발생하는 중대하면서도 까다로운 트레이드 오프를 판가름하는 기준이다.

아키텍처의 요구 사항마다 피트니스 함수가 필요하므로 각각의 관리 요소를 측정하는 방법을 찾아내야 하며 때로는 직접 고안해야 한다. 성능 피트니스 함수의 목표는 모든 유형의 성능을 측정하는 것이 아니라 아키텍트가 중요하다고 판단한 거버넌스 요소의 성능을 측정하는 것이다.

진화적 아키텍처가 피트니스 함수에 의해 유도된다함은, 아키텍처의 선택 사항 각각을 단일 또는 시스템 전체의 피트니스 함수를 통해 평가한다는 뜻이다. 결국 이러한 평가는 변화의 영향력을 반영한다. 피트니스 함수는 해당 아키텍처에서 중요한 것이 무엇인가에 대한 총체적 정의이며, 소프트웨어 시스템 개발 과정에서 발생하는 중대하면서도 까다로운 트레이드오프를 판가름하는 기준이다.

==이전에는 코드 품질, 데브옵스 메트릭, 보안 등의 다양한 아키텍처 검증 메커니즘을 모두 별개로 취급했다. 피트니스 함수는 기존의 다양한 개념을 단일 메커니즘으로 통합한다. 아키텍트는 피트니스 함수를 통해 기존의 다양하고 즉흥적인 '비기능적 요구 사항'테스트를 일관된 방식으로 고려할 수 있다.== 중요한 아키텍처 임곗값과 요구 사항을 피트니스 함수로 한데 모으면 이전에는 모호하고 주관적이었던 평가 기준을 더욱 구체적으로 표현할 수 있다.

### 2.2 범주
피트니스 함수는 스코프, 케이던스, 결과, 호출, 능동성, 커버리지 등의 다양한 범주에 걸쳐 존재한다. 

#### 2.2.1 스코프: 원자 vs 전체
원자 피트니스 함수는 단일 콘텍스트로 실행되며 아키텍처의 특정 측면을 검사한다. 모듈러 커플링처럼 하나의 아키텍처 특성을 검증하는 단위 테스트는 원자 피트니스 함수의 좋은 예다.

일부 아키텍처는 피트니스 함수를 검사할 때 아키텍처 차원 각각을 개별적으로 테스트해야 한다. 전체 피트니스 함수는 공유 콘텍스트에서 실행되며 여러 아키텍처 측면을 조합해 검사하도록 설게된다. 

==아키텍처 요소들의 모든 조합을 일일이 테스트하는 것은 불가능하므로, 아키텍트는 중요한 상호작용을 선별하고 조합해 전체 피트니스 함수를 적용해야 한다. 이러한 선별력과 순위화를 통해 아키텍트와 개발자는 특정 테스트 시나리오 구현의 난이도를 가늠하고 각각의 특성과 가치를 평가할 수 있다. 아키텍처 문제들의 상호작용 자체가 아키텍처의 품질을 좌우하는 경우가 종종 있지만, 전체 피트니스 함수로 이러한 오류를 바로잡을 수 있다. ==

#### 2.2.2 케이던스: 트리거 vs 지속 vs 시간
실행 케이던스는 피트니스 함수를 구분하는 특성이다. 트리거 피트니스 함수는 개발자나 배포 파이프라인이 실행한 단위 테스트, QA 담당자가 수행하는 탐색 테스트 등의 특정 이벤트를 기반으로 실행된다. 개발자에게 익숙한 단위 테스트, 기능 테스트, 행동 주도 개발 테스트 등이 모두 여기에 포함된다. 아키텍트는 실제 트랜잭션이 실행되는 동안 프로덕션 환경에서 또 다른 트랜잭션을 시뮬레이션하는 지속 피트니스 함수를 구축해야 한다. 이러한 기법을 흔히 합성 트랜잭션이라 부른다.

마이크로 서비스 아키텍처에서 서비스 사이의 복잡한 실제 상호 작용을 측정하려면 어떻게 해야 할까? 합성 트랜잭션은 이러한 목적으로 사용하는 일반적인 측정 기법이다. 이 기술은 시스템에 보내는 요청 트랜잭션의 합성 여부를 나타내는 플래그를 담는다. 합성 트랜잭션 요청은 통상적인 상호작용 과정을 정확히 따르며, 포렌식 분석에 쓰이는 상관관계 ID로 추적하는 경우가 많다. 

모니터링 주도 개발은 최근 많은 관심을 받는 테스트 기법이다. MDD는 시스템의 결과를 확인하기 위해 테스트에만 의존하는 대신, 프로덕션을 모니터링하고 기술적 상태와 비즈니스 현황을 동시에 평가한다. 

대부분의 피트니스 함수는 변경 상황이 발생했을 때 일시적으로, 또는 특별한 목적을 위해 지속적으로 발동된다. 그러나 간혹 아키텍트는 적합성 평가에 시간적 요소를 추가하는 경우가 있다. 시간 피트니스 함수 temporal fitness function 는 이런 상황에 쓰인다. 예를 들어, 프로젝트에서 암호화 라이브러리를 사용하는 경우 아키텍트는 일정 시간 이후 중요 업데이트가 수행되었는지 확인하는 용도로 시간 피트니스 함수를 활용할 수 있다.

#### 2.2.3 트리거 vs 지속
지속 피트니스 함수 또는 트리거 피트니스 함수를 선택하는 기준은 퀀텀의 적용 결과에 따른 트레이드 오프로 결정되고 한다. 지속 피트니스를 선택했을 경우 모든 서비스는 모니터링 정보를 노출(일반적으로 특정 포트를 통해)하고 워크플로가 진행되는 동안 자신이 호출하는 서비스가 무엇인지 알려야 한다. 

지속 피트니스 함수의 이점은 즉시성이다. 아키텍트와 이해관계자 모두는 거버넌스 위반 시점을 즉시 알 수 있다. 그러나 이러한 해결책은 런타임 오버헤드를 발생시킨다. 

피트니스 함수를 트리거 방식으로 구현하는 방법도 있다. 배포 파이프라인은 정규 케이던스에 맞추어 피트니스 함수를 호출하며 로그 파일을 수집하고 모든 통신이 이상 없는지 확인한다. 트리거 피트니스 함수의 이점은 런타임에 영향을 미치지 않는다는 것이다. 발동할 때만 실행되고 로그 레코드를 확인한다. 그러나 보안 등의 중대한 거버넌스 문제는 대응 시간이 늦어질수도록 부정적인 영향도 커진다. 이러한 분야에 트리거 피트니스를 적용하면 안 된다.

#### 2.2.4 결과: 정적 vs 동적
정적 피트니스 함수는 단위 테스트의 통과/실패처럼 고정적인 결과를 낸다. 바이너리, 숫자 범위, 집합 구성 등, 기댓값이 이미 정의되어 있는 피트니스 함수는 모두 이 범주에 든다.

동적 피트니스 함수는 외부 콘텍스트, 실시간 콘텐츠처럼 변화하는 대상을 근거로 정의된다. 예를 들어, 다중 사용자의 요청과 응답 능력으로 확장성을 판단하는 피트니스 함수를 생각해보자. 동시 사용자 수가 증가하며 응답성이 다소 저하되는 것은 아키텍트에게 별로 문제가 되지 않는다. 그러나 장애가 발생하는 순간을 놓치는 것은 용납할 수가 없다. 따라서 이러한 응답성을 평가하는 피트니스 함수는 동시 사용자 수의 변화를 고려해 평가를 조정해야 한다. 

#### 2.2.5 호출: 자동 vs 수동
아키텍트는 자동화를 좋아하며, 자동화는 점진적 변화의 일부다. 소프트웨어 개발의 모든 과정을 자동화하고 싶은 욕망만큼 소프트웨어 개발의 일부는 자동화에 저항한다. 법적 요건이나 탐색 테스트 등은 아키텍처에서 매우 중대한 차원이지만 때때로 자동화하기 매우 어려워 불가피하게 수동 피트니스 함수로 구현되고 한다. 사람이 직접 프로세스를 검증하는 수동 피트니스 함수는 다양한 분야에서 필요하다. 

#### 2.2.6 선제적: 의도 vs 긴급
이키텍트는 프로젝트 시작 단계에서 아키텍처의 특성을 파악하고 대부분의 피트니스 함수를 정의하지만, ==일부 피트니스 함수는 시스템 개발 도중에 등장하기도 한다.== 아키텍트는 공식 거버넌스 프로세스의 일부로 프로젝트 시작 단계에서 의도 피트니스 함수를 작성한다. 거버넌스를 개선할 만한 행동을 발견했을 때 ==아키텍트는 통상적으로 긴급 피트니스 함수를 만들어 대처한다. 아키텍트는 프로젝트에 잘못된 동작이 있는지 항상 주의 깊게 관찰하고, 이를 검증할 수 있는 피트니스 함수를 찾아 적극적으로 추가해야 한다. ==

#### 2.2.7 커버리지: 도메인별 피트니스 함수 
일반적으로 피트니스 함수는 문제 도메인이 아닌 추상적인 아키텍처 원칙에 따라 작동한다. 피트니스 함수는 프로젝트의 검증 메커니즘 중 하나이며, 여타 (도메인) 검증과 함께 공존해야 한다는 점을 잊어서는 안된다. ==같은 작업을 반복하지 않으려면 피트니스 함수는 순수한 아키텍처 문제로 한정하고 도메인의 문제는 다른 검증 절차에서 처리하도록 하는 것이 현명한 조치다.== 탄력성은 피트니스 함수로 관리해야 한다. 반면, 주소 변경 처럼 도메인 지식이 필요한 기능을 담당하는 팀은 전통적인 검증 메커니즘을 활용한다. 

### 2.3 피트니스 함수는 누가 작성하는가
피트니스 함수는 단위 테스트에 대한 아키텍처의 아날로그적 해석이다. 일반적으로 아키텍트는 중요한 아키텍처 특성의 객관적인 척도를 세우기 위해 피트니스 함수를 작성한다. 아키텍트와 개발자는 모두 피트니스 함수를 관리하며 항상 유효한 상태를 유지해야 한다.  아키텍트는 개발자와 협업하며 피트니스 함수의 목적과 활용 방안을 정의하고 함께 이해해야 한다. 둘 사이에 긴밀한 협업 관계가 형성되어야 한다. 

### 2.4 피트니스 함수 테스트 프레임워크 선택
문제 도메인을 테스트할 때 개발자는 플랫폼별 도구를 활용한다. 모데인은 의도적으로 특정 플랫폼과 기술 스택에 맞추어 개발되기 때문이다. 아키텍트 또한 플랫폼과 비슷한 수준에서 아키텍처 피트니스 함수를 지원하는 턴키 도구를 찾고자 하지만, 일반적으로 이러한 도구는 존재하지 않는다. 피트니스 함수를 검증하는 도구는 도메인 테스트 라이브러리에 비하면 매우 드문 편이다. 

### 2.5 결과 vs 구현
아키텍트에게 결과는 상세 구현보다 더 중요하다. 결과는 아키텍처 특성을 객관적으로 나타내는 척도다. 피트니스 함수라는 용어에서 '함수'가 지닌 중요한 함의는, 무언가를 입력받아 부작용 없이 출력을 생성한다는 것이다. 비슷하게 피트니스 함수는 아키텍처 특성에 대한 객관적인 평가를 도출한다. 그것이 피트니스 함수의 결과다. 

또한 피트니스 함수들을 한데 모아 시스템 피트니스 함수 system-side fitness function 라는 개념을 부여할수 있다. 피트니스 함수는 각각 하나 이상의 아키텍처 차원에 할당된다. 이들이 서로 충돌하는 상황이 발생하면 시스템 피트니스 함수를 통해 문제 해결에 필요한 트레이드오프를 파악할 수있다. 다기능 최적화 multifunction optimization 문제가 흔히 그렇듯 피트니스 함수 역시 모든 값을 동시에 최적화하는 것이 불가능한 경우가 있다. 결국 아키텍트는 선택을 강요당한다. 가령 아키텍처 피트니스 함수에서 성능과 보안은 암호화 비용을 두고 서로 충돌하기 쉽다. 이는 모든 아키텍트를 괴롭히는 전형적인 문제, 다시 말해 트레이드오프다. 

아키텍트는 피트니스 함수가 제공하는 객관적인 지표를 통해 각각의 힘이 작용하는 방식을 보다 명확하게 이해하고 시스템 전반의 트레이드오프를 추론하는 근거로 삼는다.

> 시스템은 결코 부분의 합이 아니다. 각 부분이 이루는 상호작용의 산물이다. -러셀 애코프 박사

## 3. Engineering Incremental Change

진화적 아키텍처는 다양한 차원에 걸쳐 점진적 변화를 유도하는 아키텍처다. 점진적 변화란 일련의 사소한 변화를 통해 아키텍처 전체의 변화를 달성한다는 의미다. 이번 장은 점진적 변화를 따르는 진화적 아키텍처와, 이러한 목표를 달성하기 위해 활용되는 엔지니어링 사례를 소개 한다. 점진적 변화는 두 가지 측면에서 논의한다. 한쪽은 소프트웨어를 구축하는 개발자의 관점, 다른 한쪽은 소프트웨어를 배포하는 운영자의 관점이다.

### 3.1 점진적 변화

마이크로서비스는 기술적 커플링을 없애고 각 서비스를 운영적으로 분리하는 무공유 아키텍처를 지향한다. 따라서 아키텍처의 변화는 세분화된 수준에서 촉진된다. 
![[Screenshot 2024-02-29 at 11.27.21 AM.png]]
신기능이 담긴 버젼은 아래에서 보듯이 기존 버젼을 두고 추가로 공개된다.
![[Screenshot 2024-02-29 at 11.28.32 AM.png]]
등급 기능을 사용하는 모든 서비스가 반드시 신규 서비스로 마이그레이션할 필요는 없다. 각 서비스는 원하는 시점에 점진적으로 더 나은 서비스를 전환할 수 있다. 신버젼을 사용하는 서비스는 시간이 흐를수록 생태계 안에서 점점 늘어난다. 데브옵스 기법을 도입해, 서비스뿐만 아니라 서비스가 주고받는 통신 경로도 추적한다. 운영 그룹은 일정시간 동안 서비스를 관찰하다가 라우팅 내역이 없는 서비스를 발견하면 아래와 같이 서비스를 생태계에서 자동으로 분리한다. 
![[Screenshot 2024-02-29 at 11.31.13 AM.png]]
개발팀이 신규 서비스를 배포할 때, 기존 서비스를 호출하는 다른 서비스까지 강제로 업그레이드할 필요는 없어야 한다. 따라서 아키텍트는 별점 서비스 엔드포인트를 잠시 프록시로 변경하고 서비스 요청 버전을 확인한 뒤 각각에 맞게 라우팅 한다. 기존 서비스는 기존 별점 서비스를 그대로 사용하며 새로 추가되는 서비스는 곧바로 신버젼에 연결된다. 기존 별점 기능을 호출하는 서비스는 강제로 업그레이드할 필요가 없으며 필요에 따라 기존 버젼을 계속 호출할 수 있다. 추후 새로운 기능을 사용하기로 결정했을 때 엔드포인트의 요청 버전을 변경하면 별점 서비스를 교체할 수 있다.시간이 흐르면 기존 버전을 호출하는 서비스는 점점 줄어들고, 더 이상 필요치 않게 되는 순간 아키텍트는 엔드포인트에서 이전 버전을 제거할 수 있다. 

아키텍처의 모든 변경 사항은 배포 파이프라인의 관리 하에 반영된다. 데이터베이스 가은 외부 ㅋ멈포넌트의 프로비저닝도 마찬가지다. 배포 과정에서 각기 이동하는 이질적인 요소들을 데브옵스가 직접 조정할 필요는 없다. 

일단 피트니스 함수를 정의하면 반드시 적시에 실행하고 평가할 수 있어야 한다. 자동화는 지속적 평가의 핵심 요소이며, 이러한 평가는 배포 파이프라인에서 진행되는 경우가 많다. 아키텍트는 배포 파이프라인을 통해 어떤 피트니스 함수를 언제, 얼마나 자주 실행할지 정의할 수 있다.

#### 3.1.1 배포 파이프라인
배포 파이프라인 메커니즘은 지속적 전달(continuous delivery) 기술에 속한다. 지속적 통합 서버와 마찬가지로 배포 파이프라인은 변경 사항을 '수신'하고 일련의 검증 단계를 실행한다. 지속적 배포 관행은 배포 파이프라인 자동화를 권장한다. 테스트 머신 프로비저닝, 배포 등의 통상적인 프로젝트 업무는 모두 배포 파이프라인 멬커니즘을 통해 자동화시키는 것이 좋다. 배포 파이프라인을 구축할 때 사용하는 오픈 소스 도구로는 GoGD등이 있다.

배포 파이프라인은 아키텍처에 정의된 피트니스 함수를 실행할 이상적인 장소를 제공한다. 또한 다양한 수준의 추상화와 정교한 테스트를 통합해 여러 단계를 구성하며, 시스템이 조금이라도 변경될 때마다 피트니스 함수를 실행한다. 아래의 그림은 피트니스 함수가 추가된 배포 파이프라인을 나타낸다.
![[Screenshot 2024-02-29 at 11.46.23 AM.png]]
진화적 아키텍처 프로젝트는 지속적 배포를 지향한다. 파이프라인이 세운 테스트와 검증의 장벽을 무사히 통과한 변경 사항만 지속적으로 프로덕션에 반영해야 한다. 

==아키텍트가 엔지니어링 실무에서 배포 파이프라인을 활용하면 프로젝트 피트니스 함수를 손쉽게 적용할 수 있다. 일반적으로 개발자는 배포 파이프라인을 설계하며 각 단계의 필요성을 판단하는 데 어려움을 겪는다. 그러나 배포 파이프라인 내부에 피트니스 함수가 추가되면 아키텍 트와 개발자는 변경 사항으로 인한 진화가 프로젝트 가이드 라인을 위반하지 않을 것이라는 높은 수준의 확신을 갖게 된다. ==아키텍처의 문제는 불확실하고 주관적인 방식으로 드물게 평가되는 경우가 많다. 이러한 평가를 피트니스 함수로 구현하면 평가의 엄밀성을 높이고 엔지니어링 관행에 대한 신뢰도를 높일 수 있다.

### 3.1.3 자동화 빌드의 API 일관성 검증
https://docs.pact.io/ 
API 변경에 대비해 아키텍트는 피트니스 함수 실행 단계를 나누었다. 검증 체인 1단계는 openapi.yaml 에 게시된 신규 API의 설계 및 정의에서 시작된다. 팀은 Spectral 또는 OpenAPI.Tools 를 사용해 신규 스펙 구조와 기타 요소로 검증한다. 

검증 체인 2단계는 신규 스펙을 채택하고 샌드박스 환경에 게시해 테스트한다. 샌드박스 환경이 활성화되면 배포 파이프라인은 일련의 단위 및 기능 테스트를 실행해 변경 사항을 검증한다. 2단계의 목표는 해당 API를 사용하는 애플리케이션이 이전과 동일하게 작동하는지 검증하는 것이다. 

표시된 3단계에서는 Pact 를 사용해 통합 이키텍처 영역을 테스트한다. Pact는 소비자 주도 계약 이라는 개념을 실제로 구현한 도구로, 서비스 간 통합 테스트를 수행하며 통합 지점을 보존한다. 

진화적 아키텍처의 점진적 변화에 내포된 암묵적인 전제 중 하나는 개발팀의 엔지니어링 성숙 도다. 소비자 주도 계약 기법을 사용한다 해도 빌드 중단 기간이 며칠이나 지속된다면 더 이상 통합 지점의 유효성을 보장할 수 없다. 피트니스 함수가 엔지니어링 관행으로 정착되면 많은 개발자의 고단한 수작업이 줄어든다. 그러나 이러한 혜택을 누리려면 개발자의 능력이 일정한 성숙도에 도달해야 한다.


## 4. Automating Architecture Governance 
아키텍트의 임무는 소프트웨어 시스템의 구조를 설계하고 수많은 개발 원칙과 엔지니어링 관행을 정의하는 것이다. 그러나 아키텍트가 소홀히 하면 안 될 또 다른 중요한 책임은 거버넌스 다. 아키텍트는 소프트웨어 구축 과정을 관리하며 설계 원칙과 모범 사례를 따르고 알려진 시행착오를 방지해야 한다.

자동화된 피트니스 함수의 등장으로 이전보다 (수동 코드 리뷰, ARB) 거버넌스 정책을 잘 집행할 수 있는 새로운 능력을 얻었다. 

#### 4.1 피트니스 함수와 아키텍쳐 거버넌스
진화적 아키텍처의 메커니즘은 아키텍처 거버 넌스 architectural governance , 특히 소프트웨어 엔지니어링 관행의 진화를 상징하는 거버넌스 자동화 automating governance 와 겹치는 부분이 많다는 사실이 밝혀졌다.



# PART 2. Structure

^f4c74f

## 5. Evolutionary Architecture Topologies
## 6. Evolutionary Data
# PART 3. Impact

^8ab233

## 7. Building Evolvable Architectures
## 8. Evolutionary Architecture Pitfalls and Antipatterns
## 9. Putting Evolutionary Architecture into Practice