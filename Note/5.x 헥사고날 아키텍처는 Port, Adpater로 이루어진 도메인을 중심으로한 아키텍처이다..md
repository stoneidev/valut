[[5.x.0 헥사고날 아키텍처의 중요한 세 가지 헥사곤]]
[[5.x.2 헥사고날 아키텍처의 Tradeoff]]

01. 왜 헥사고날 아키텍처인가?
	- 소프트웨어 아키텍처 검토
		단지 동작하는 소프트웨어가 아닌, 쉽게 유지보수할 수 있고 잘 구성된 소프트웨어를 만들려고 하는 경우 소프트웨어를 만들기 위해 도입한 세부사항에 대한 주의와 관심 때문에 어느 정도 소프트웨어를 일종의 예술로 간주할 수 있다. 그러면 이를 소프트웨어 아키텍처에 대한 고결한 정의로 볼 수도 있다.
		
		소프트웨어 아키텍처는 한 사람이 가진 생각의 결실이 되어서는 안 된다. 가이드를 제공하고 기반을 구축해 다른 사람들이 기술적으로 우수한 길로 나아가도록 촉구하는 사람도 있지만, 이키텍처가 진화하고 성숙하기 위해서는 소프트웨어 품질을 개선하기 위한 활동과 관련된 모든 사람과의 협업과 경험이 필요하다. 
	- 보이지 않는 것들
		고객은 그들이 볼 수 있는 것, 비즈니스 기대치를 만족하면서 동작하는 소프트웨어에 관심을 가진다. 그것이 고객이 돈을 지불하는 이유이다. 
		
		그러나 고객이 볼 수 없는 것 또한 어느 정도 중요하다. 이러한 것을 비기능 요구사항이라고 한다. 보안, 유지보수성, 운영 가능성, 그리고 다른 기능과 관련된 것들이다. 고객 관점에서 볼 수 없는 이러한 것들에 적절한 주의를 기울이지 않으면 그것들이 소프트웨어의 목적을 손상시킬 수 있다. 이러한 타협은 미묘하고 점진적으로 발생할 수 있으며, 기술 부채를 포함한 여러 문제의 원인이 된다.
		 
		소프트웨어 아키텍처는 무언가를 올바르게 만드는 것에 관한 것이라고 언급했다. 따라서 이것은 소프트웨어 아키텍처의 관심사 중에서 보이는 것과 보이지 않는 것 모두를 포함해야 함을 의미한다. 고객에게 보이는 것, 문제 영역에 대한 깊은 이해가 필수적이다.
	- 기술 부채
		 워드 커닝햄이 만든 기술 부채라는 용어는 소프트웨어 코드내에 존재하는 불필요한 복잡성이 얼마나 존재하는지를 설명하는 데 사용된다. 이런 불필요한 복잡성을 크러프트라고 한다. 크러프트는 현재 코드와 이상적인 코드와의 차이다. 우리는 소프트웨어 프로젝트에서 기술 부채가 어떻게 나타날 수 있는지에 대해 곧바로 학습할 것이다. 
	- 악순환
		 재정 부채는 갚을수록 계속해서 증가하는 경향이 이다. 재정 부채와 다르게, 기술 부채는 처리하지 않는다고 해도 반드시 드러나지는 않는다. 기술 부채의 증가를 결정하는 것은 소프트웨어의 변경 속도와 특성이다. 그렇기 때문에 빈번하고 복잡한 변경이 있으면 기술 부채가 증가할 가능성이 더 높다. 
		 
		 기술 부채를 통제하지 못하면 결국 과부하된 기술 부채 시스템에 새로운 기능을 추가할 만한 가치가 없게 될 것이다. 그 시점에는 애플리케이션을 포기하고 새로운 애플리케이션을 만들기 시작한다. 그리고 이러한 주기가 반복된다. 따라서 이러한 주기를 깨기 위해서라고 기술 부채를 해결하려는 활동을 촉진해야 한다. 
	- 아키텍처 관련 의사 결정
		 소프트웨어 설계에 있어 중요한 포인트는 시스템 변경의 필요성과 능력이다. 선행 설계에 너무 많은 노력을 들이면, 결국 과도한 엔지니어링으로 인해 솔루션이 비싸질 수 있다. 반대로 설계에 대해 신경을 쓰지 않으면 변경 비용이 증가할 위험이 있다. 익스트림 프로그래밍에서 지적했듯이 설계에 사용된 리소스는 변경을 처리하는 비용을 증가시키지 않고 변경을 수용 가능한 속도로 처리하기 위한 시스템의 요구와 일치해야 한다. 

	- 헥사고날 아키텍처 이해
		 "여러분의 애플리케이션을 UI나 데이터베이스 없이 동작하도록 만드십시오. 그러면 애플리케이션에 대해 자동화된 회귀 테스트를 실행할 수 있고, 데이터베이스를 사용할 수 없을 때도 동작합니다. 그리고 어떤 사용자의 개입 없이도 애플리케이션을 함께 연결할 수 있습니다." - 알리스테어 코크번

		 헥사고날 아키텍처의 주된 아이디어 중 하나는 비즈니스 코드를 기술 코드로부터 분리하는 것이다. 그 뿐만 아니라 기술 측면이 비즈니스 측면에 의존하는지도 확인해 비즈니스 측면이 비즈니스 목표를 달성하는 데 사용되는 기술에 대한 우려 없이도 발전할 수 있게 해야 한다. 도한 관련된 비즈니스 코드에 피해를 주지 않고도 기술 코드를 변경할 수 있어야 한다. 이러한 목표를 달성하려면 비즈니스 코드가 어디에 존재해야 하는지, 기술 문제로부터 격리되고 보호돼야 하는 위치를 결정해야 한다. 이것은 우리의 첫 번째 헥사곤, 즉 도메인 핵사곤을 생성하게 할 것이다. 
		 
		 도메인 헥사곤에서는 소프트웨어가 해결하기를 원하는 핵심 문제를 설명하는 요소들을 결합한다. 해당 헥사곤에서는 DDD를 활용할 수도 있다.
		 
		 또한 도메인 헥사곤에서 나오는 비즈니스 규칙을 사용, 처리하고 조정하는 방법이 필요하다. 이는 애플리케이션 헥사곤이 하는 일이다. 애플리케이션 헥사곤은 비즈니스 측면과 기술 측면 사이에 있으며, 양쪽과 상호작용하는 중개자 역할을 한다. 애플리케이션 헥사곤은 포트와 유스케이스를 활용해 이러한 기능을 수행한다. 
		 
		 프레임워크 헥사곤은 외부 인터페이스를 제공한다. 프레임워크 헥사곤은 애플리케이션 기능의 노출 방법을 결정할 수 있는 곳이다. 예를 들어, 프레임워크 헥사고에서 REST나 gRPC 엔드포인트를 정의한다. 외부 소스에서 무언가를 소비하기 위해 데이터베이스, 메시지 브로커, 또는 다른 시스템에서 데이터를 가져오는 메커니즘을 정의하기 위해 프레임워크 헥사곤을 사용한다. 헥사고날 아키텍처에서는 어댑터를 통해 기술 결정을 구체화한다. 
		 
		  ![[Screenshot 2024-01-29 at 5.42.56 PM.png]]
				
	- 도메인 헥사곤
		 도메인 헥사곤은 실 세계 문제를 이해하고 모델링하는 활동을 나타낸다. 이 임무는 사소한 것이 아니다. 이 작접에 참여하는 개발자들은 도메인 전문가나 해당 도메인 문제를 이미 알고 있는 개발자에게 조언을 구해야 한다. 
		도메인 헥사곤 안에는 중요한 비즈니스 데이터와 규칙에 관련된 엔티티들이 있다. 도메인 헥사곤은 문제 영역을 표현하는 데 유용한 모든 종류의 객체들과 구성된다는 점에 주의하라. 다음 그림은 엔티티와 값 객체를 기반으로 도메인 헥사곤을 나타낸 것이다. 

		- 엔티티
		    엔티티는 좀 더 표현력 있는 코드를 작성하는 데 도움을 준다. 엔티티는 객체를 특징짓는 것은 연속성과 정체성에 대한 감각이다. 
		- 값 객체
		    값 객체는 무언가 고유하게 시별한 필요가 없는 경우는 물론이고, 객체의 정체성보다 속성에 관심을 갖는 경우에도 코드의 표현력을 보완하는 데 도움이 된다. 값 객체를 사용해 엔티티 객체를 구성할 수 있다. 

	- 애플리케이션 헥사곤
	    지금까지 도메인 헥사곤이 비즈니스 규칙을 엔티티와 값 객체로 객체 캡슐하는 방법에 대해 논의 했다. 애플리케이션 헥사곤은 애플리케이션 특화 작접을 추상적으로 처리하는 곳이다. 아직 기술 관심사를 직접 다루지 않기 때문에 추상적인 것을 이야기 한다. 이 핵사곤은 도메인 비즈니스 규칙에 기반한 소프트웨어 사용자의 의도와 기능을 표현한다. 
	    
	    - 유스케이스 : 유스케이스는 도메인 제약사항을 지원하기 위해 시스템의 동작을 소프트웨어 영역 내에 존재하는 애플리케션 특화 오펴레이선을 통해 나타난다. 자바에서 유스케이스는 소프트웨어가 할 수 있는 것을 표현하는 인터페이스로 정의된 추상화로 나타낸다. 
	    - 입력 포트 : 유스케이스가 소프트웨어가 하는 일을 설명하는 인터페이스라면 여전히 유스케이스 인터페이스를 구현해야 한다. 이것이 입력 포트의 역할이다. 애플리케이션 수준에서 유스케이스에 직접 연결되는 컴포넌트가 되기 때문에 입력 포트는 도메인 용어로 소프트웨어의 의도를 구현할 수 있게 한다.
	    - 출력 포트 : 유스케이스가 목표를 달성하기 위해 외부 리소스에서 데이터를 가져와야 하는 상황이 있다. 이것이 출력 포트의 역할이다. 출력 포트는 유스케이스나 입력 포트가 오퍼레이션을 수행하기 위해 어떤 종류의 데이 터를 외부에서 가져와야 하는지를 기술에 구애받지 않고 설명하는 인터페이스로 표현된다. 여기서 출력 포트가 기술에 구애받지 않는다고 말한 것은 예를 들어, 해당 데이터가 특정 관계형 데이터베이스 기술 이나 파일 시스템에서 오는지 신경 쓰지 않기 때문이다. 

	- 프레임워크 헥사곤
		 도메인 헥사곤으로 제한되는 중요한 비즈니스 규칙은 모든 것이 잘 구성된 것처럼 보인다. 다음으로 유스케이스, 입력 포트, 출력 포트를 통해 일부 애플리케이션 특화 오퍼레이션을 다루는 애플리케이션 헥사곤이 뒤따른다. 이제 소프트웨어와 통신할 수 있는 기술을 결정해야 하는 순간이 왔다. 통신은 두 가지 형태로 발생할 수 있다. 하나는 드라이빙(driving) 방식이고 다른 하나는 드리븐(driven) 방식이다. 다음 다이어그램에서 볼 수 있듯이, 드라이버 관점의 경우는 입력 어댑터(Input Adapter)를 사용한다.

		- 드라이빙 오퍼레이션과 입력 어댑터
			 드라이빙 오퍼레이션(Driving operation)은 소프트웨어에 동작을 요청하는 것이다. 예를 들어, 드라이빙 오퍼레이션은 명령행 클라이언트를 갖는 사용자나 사용자를 대신하는 프런트엔드 애플리케이션이될 수 있다. 소프트웨어에 의해 노출된 항목들의 정확성을 검사하는 일부 테스트 스위트가 있을 수 있다. 또는 노출된 일부 소프트웨어 기능과 상호작용이 필요한 대규모 생태계 내의 다른 애플리케이션일 수도 있다. 이러한 통신은 입력 어댑터 상단에 구축된 애플리케이션 프로그래밍 인터페이스(API)를 통해 일어난다.
			 
		- 드리븐 오퍼레이션과 출력 어댑터
			 드라이빙 오퍼레이션의 반대편에는 드리븐 오퍼레이션(Driven operation)이 있다. 이 오퍼레이션은 애플리케이션에서 트리거되고, 외부에서 소프트웨어 요구사항을 충족시키는 데 필요한 데이터를 가져온 다. 일반적으로 드리븐 오퍼레이션은 일부 드라이빙 오퍼레이션에 응답해 발생한다. 상상할 수 있듯 출력 어댑터를 통해서 드리븐 오퍼레이터를 정의한다. 이 어댑터는 그것들을 구현하는 출력 포트와 일치해야 한다.
			 
			 출력 포트는 일부 애플리케이션 특화 작업을 수행하는 데 필요한 데이터의 종류를 알려준다는 점을 기억 하자. 데이터를 어떻게 가져올지 설명하는 것은 출력 어댑터에 달려 있다.

				![[Screenshot 2024-01-30 at 10.12.33 AM.png]]

	- 헥사고날 접근 방식의 장점
		  여러 공급업체와 대규모 프로젝트를 진행해보고, 같은 기반 코드에 기여할 수 있는 새로운 개발자를 데려와 써본 수많은 경험에 비추어 보면, 헥사고날 아키텍처는 조직이 소프트웨어를 구성하는 기본 원칙을 수립하는 데 도움이 된다. 프로젝트를 전환할 때마다 개발자는 이전 프로젝트에서 획득한 헥사고날 원칙에 대해 이미 알고 있기 때문에 소프트웨어가 어떤 구조로 되어 있는지 이해하기 위한 완만한 학습 곡선을 갖게 된다. 이러한 요소는 특히 기술 부채가 적은 소프트웨어가 가져다주는 장기적인 이점과도 관련이 있다.
		  
		변경과 테스트가 쉬운, 유지보수하기 좋은 애플리케이션은 언제나 환영받는다. 이제 헥사고날 아키텍처가 이러한 장점을 얻는 데 어떻게 도움이 되는지 살펴보자.

		- 변경 허용
			헥사고날 아키텍처의 포트와 어댑터라는 특성은 마찰이 적고 기술 변화를 흡수할 준비가 되어 있는 애플리케이션을 위한 아키텍처 원칙을 강력한 이점으로 제공한다
		- 유지보수성
			  알다시피 비즈니스 규칙을 변경해야 경우 유일하게 변경해야 하는 것은 도메인 헥사곤이다. 반면, 아직 애플리케이션에서 지원하지 않는 특정 기술이나 프로토콜을 사용하는 기존 기능을 고객이 트리거할수 있게 허용해야 하는 경우 프레임워크 헥사곤에서 실행할 수 있는 새로운 어댑터를 생성하기만 하면 된다.
		- 테스트 용이성
			  헥사고날 아키텍처의 궁극적인 목표 중 하나는 알리스테어 코크번이 말한 것처럼 UI와 데이터베이스 같은 외부 의존성이 없더라도 개발자가 애플리케이션을 테스트할 수 있게 하는 것이다. 그러나 이것은 헥사고날 아키텍처가 통합 테스트를 무시한다는 의미는 아니다. 이와는 별개로, 헥사고날 아키텍처는 코드의 가장 중요한 부분을 테스트하는 데 필요한 유연성을 제공함으로써 더욱더 계속해서 통합하는 방식을 허용한다. 이는 기술 의존성이 없는 경우에도 마찬가지다.

02. 도메인 헥사곤으로 비즈니스 규칙 감싸기
     문제 영역을 모델링하는 기법 중에서 도메인 주도 설계(DDD)가 비즈니스에 대한 지식을 전달하는 매개체로 소프트웨어 코드를 강조하는 프로젝트에서 광범위하게 채택된다. 핵심 문제 영역을 구성하는 것과 부차적인 것을 분리하려고 한다는 점에서 DDD는 기술 코드를 비즈니스 코드에서 분리하는 헥사고날 아키텍처의 목표를 지원하는 적합한 방법이다.
     
	 - 엔티티를 활용한 문제 영역 모델링
		 DDD에서는 코드를 작성하기 전에 개발자와 비즈니스를 깊게 이해하는 도메인 전문가 사이에서 많은 논의가 있어야 한다. 이러한 논의는 개발자와 도메인 전문가 사이의 브레인스토밍에 기반한 지식 크런칭(knowledge crunching) 과정을 통해 귀중한 정보를 제공한다. 그다음, 해당 지식은 보편 언어 (Ubiquitous Language)를 통해 통합된다. 이 언어는 프로젝트와 관련된 모든 사람 사이에서 공용어 (lingua franca) 역할을 하고, 문서, 일상 대화, 코드에도 존재하게 된다.
		 
		 엔티티를 다룰 때는 코드를 읽는 것만으로 비즈니스에 대해 얼마나 많이 배울 수 있는지 항상 유념해야 한다. 진정으로 가치 있는 것은 보편 언어를 계속해서 발전시키고 코드가 그 언어로 말할 수 있도록 지식 크런칭 기법을 사용할 때 발생하기 때문이다. 이것은 실제로 유의미한 동작을 포착하고 단순 데이터 객체 이상이 되는 풍부한 엔티티의 기반이 된다.
		 
		- 도메인 엔티티의 순수성
			 문제 영역을 모델링할 때 주된 초점은 가능한 한 정확하게 실제 시나리오를 코드로 변환하는 것이다. 문제 영역에 대한 모델링 활동은 수익을 얻고 소프트웨어에 의존하는 조직 전반의 성공을 결정하는 데 중요하다. 비즈니스 요구사항을 이해하고 코드로 변환하는 데 실패하면 결과적으로 비용의 손실이 발생할 수밖에 없다. 
			 
			 문제 영역 모델링의 핵심은 엔티티를 만드는 것이다. 엔티티가 비즈니스 요구사항과 밀접한 관계를 가져야 하기 때문에 이러한 엔티티를 기술적인 요구사항으로부터 보호하기 위해 노력해야 한다. 비즈니스 관련 코드와 기술 관련 코드가 혼동되는 것을 방지하기 위해 노력해야 한다. 여기서 기술적이라는 말은 소프트웨어 맥락에서만 존재하고 의미가 있다는 것을 말한다. 
			 
			 **도메인 엔티티는 비즈니스 관심사만 처리한다는 점에서 순수해야 한다. 기술에 특화된 경우라면, 다음 장에서 살펴보겠지만 포트, 유스케이스, 어댑터를 활용할 수 있는 특권을 갖고 있다.**
		- 관련 엔티티
			 비즈니스 규칙과 비즈니스 데이터라는 두 요소의 존재는 관련 엔티티의 특징을 결정한다. 빈약한 도메인 모델(anemic domain model)에서 나오는 엔티티 객체는 데이터는 있지만 동작은 부족하다. 동작과 데이터가 결합되지 않으므로, 빈약한 도메인 모델은 객체지향 프로그래밍의 본질에 반한다. 도메인 객체에 동작이 존재하지 않는 경우에는 엔티티가 무엇을 해야 하는지를 완전하게 파악하기 위해 다른 곳으로 가야 한다. 그로 인해 기반 코드가 커지면 금방 부담될 만한 번거로운 과부하가 생긴다.
		- UUID를 이용한 식별자 정의
			 식별자(ID: Identifier)의 중복 생성 및 방지를 위해 데이터베이스 시퀀스 메커니즘에 의존하는 식별자 생성 기법에 익숙한 사람도 있을 것이다. 이러한 책임을 데이터베이스에 위임하는 것이 편리하지만 그렇게 함으로써 소프트웨어의 중요 부분을 외부 시스템과 결합하게 된다.
			 
			 UUID는 조심해서 써야 한다. 데이터 소스가 관계형 데이터베이스인 경우에는 성능 문제가 발생할 수있다. UUID는 문자열이기 때문에 관계형 데이터베이스에서 제공하는 자동 생성된 ID로 만들어진 정수 보다 더 많은 메모리를 소비한다. UUID를 사용하면 데이터베이스의 크기와 인덱스 관리에 상당한 영향을 줄 수 있다. 공짜 점심은 없다. 이처럼 기술에 구애받지 않는 ID 생성 솔루션에 컴퓨터 리소스를 비용 으로 지불해야 한다.
			 
			 엔티티는 헥사고날 아키텍처의 일급 객체(first-class citizen) 다.
	- 값 객체를 통한 서술력 향상
		 도메인 주도 설계 구현에서는 문제 영역에서 사물을 측정하고, 수량화하거나 서술하기 위해 값 객체를 사용해야 한다는 점을 상당히 잘 지적했다. 예를 들어, long이나 int 형 값 대신 값 객체를 통해 ID속성을 기술할 수 있다. double이나 big decimal 속성을 특정 값 객체로 감싸서 수량화를 좀 더 명확하게 표현할 수 있다. 
		  
		 문제 영역을 모델리하기 위해 프로그래밍 언어의 내장 타입만 사용하는 것으로는 충분하지 않다. 시스템의 본질과 목적을 더욱 명확하게 하기 위해 이러한 내장 타입, 심지어 우리가 생성한 타입도 잘 정의된 객체로 감싸야 한다. 
		  
		 의미를 전달하려는 이 같은 노력은 값 객체에 대한 다음 두 가지 기본 특성을 기반으로 한다. 
		  
		- 값 객체는 불편이다. 
		- 값 객체는 식별자를 갖지 않는다. 
		
	- 애그리게잇을 통한 일관성 보장
		  엔티티와 값 객체의 그룹이 함께 전체적인 개념을 설명하는 경우에는 어떻게 할까? 이런 상황에서는 애그리게잇을 사용해야 한다. 이때 애그리게잇 내부의 객체들은 일관되고 격리된 방식으로 동작한다. 이러한 일관성을 달성하려면 애그리게잇 객체에 대한 모든 변경은 해당 애그리게잇에 부과되는 변경 사항에 따라 결정되는 것이 보장돼야 한다. 
		  
		 애그리게잇은 객체의 데이터와 동작을 조정하는 오케스트레이터와 같다. 그러자면 애그리게잇 영역과 상호작용할 진입점을 정의해야 한다. 이러한 진입점은 애그리게잇 루트로 알려져 있으며, 애그리게잇의 일부인 엔티티와 값 객체들에 대한 참조를 유지한다. 애그리게잇이 제공하는 바운더리를 통해 바운더리 내부의 객체가 수행하는 오퍼레이션에서 더 나은 일관성을 보장할 수 있게 된다. 
		 
		 성능과 확장성 관점에서 항상 애그리게잇을 가능한 한 작게 유지하기 위해 노력해야 한다. 일반적으로 작은 애그리게잇은 애그리게잇 루트로 동작하는 엔티티와 다른 값 객체들을 포함한다. 두 개의 서로 다른 애그리게잇이 상호작용하게 만드는 방법은 애그리게잇 루트를 사용하는 것이다. 
	- 도메인 서비스 활용
		 애그리게잇 내부의 객체들은 일관되고 격리된 방식으로 동작한다. 이러한 일관 성을 달성하려면 애그리게잇 객체에 대한 모든 변경은 해당 애그리게잇에 부과되는 변경 사항에 따라 결정되는 것이 보장돼야 한다. 도메인 서비스는 엔티티와 값 객체 클래스가 문제 영역을 따라 필요 이상으로 많은 기능을 가지고 너무 커지는 것을 방지하기 위한 가치있는 활동이기도 한다.

	- 정책 패턴과 명세 패턴을 활용한 비즈니스 규칙 처리
		 시스템이 가지고 있는 가장 큰 가치 중 하나는 **성문화된 비즈니스 규칙**이다. 이러한 규칙은 실제 문제를 이해하고, 이해한 바를 동작하는 소프트웨어로 변환하기 위한 필수적인 노력을 나타낸다. 
		  
		정책 패턴과 명세 패턴은 비즈니스 규칙을 더 잘 구조화하기 위한 두 가지 패턴이다. 
		
		정책은 전략으로도 알려져 있으며, 코드 블록으로 문제 여역의 일부를 캡슐화하는 패턴이다. 전략 패턴에 익숙한 사람들은 알고리즘이라는 용어를 캡슐화된 코드 블록을 설명하는 데 사용할 수 있다. 정책의 주된 특성은 제공된 데이터에 대해 어떤 작업이나 처리를 한다는 점이다. 정책은 커플링을 피하기 위해 의도적으로 엔티티와 값 객체를 분리해 유지한다. 이러한 디커플링은 직접적인 영향이나 부작용 없이 한 부분을 발전시키는 잘 알려진 혜택을 적용한다. 
		
		반면, [명세(Specification)](https://medium.com/@pawel_klimek/domain-driven-design-specification-pattern-82867540305c)는 객체의 특성을 보장하는 데 사용되는 조건(condition)이나 프레디케이트(predicate)와 같다. 그러나 명세의 특징은 단순한 논리적인 연산자보다는 더 표현적인 방법으로 프레디케이트를 캡슐화한다는 것이다. 이러한 명세들을 캡슐화하면 재사용할 수 있고 함께 결합해서 문제 영역을 더 잘 표현할 수 있다.
		
		함께 사용한다면 정책과 명세는 코드 전반에 걸쳐 비즈니스 규칙의 견고성과 일관성을 향상시키는 믿을 만한 기법이다. 명세는 정책에 적합한 개체만 처리되는 것을 보장한다. 우리는 정책을 통해 다양하면서도 손쉽게 변경할 수 있는 알고리즘들을 자유자재로 활용할 수 있다. 

	- POJO를 통한 비즈니스 규칙 정의
	    POJO는 일반적인 자바 객체에 불과하기 때문에 매력적이다. 사용자 정의 라이브러리와 프레임워크가 아닌 자바 표준 API만 다루기 때문에 이해하기 쉽다. 이것은 POJO를 개발자 친화적인 객체로 만들며, 애플리케이션의 여러 부분에서 이해하고 재사용하기가 더 쉽다.

03. 포트와 유스케이스를 통한 동작 처리
	- 유스케이스를 통한 소프트웨어 동작 표현
		소프트웨어 시스템은 사용자나 다른 소프트웨어 시스템이 정의한 목표를 달성하기 위해 함께 동작하는 일련의 행위 집합에 불과하다. 다시 말해, 소프트웨어의 동작은 단독, 혹은 다른 소프트웨어 동작과 결합해 가치 있는 소프트웨어 목표를 실현하는 데 기여하는 의미 있는 행동이다. 이러한 목표는 사용자나 시스템이 관심을 갖고 표현하는 요구사항과 밀접하게 연결되어 있다.
		
		다이어그램 간의 관계를 통해 시스템의 상위 수준 뷰를 설명하는 UML과 달리, 유스케이스는 SuD 행위의 상세한 글로 작성된 디스크립션을 제공하는 심층 분석을 수행한다. 유스케이스는 SuD 목표, 목표를 충족하기 위한 수단이나 행위, 가능한 실패 시나리오와 이들이 발생하는 경우에 수행해야 할 작업을 설정하는 귀중한 기법이다. DDD 기법과 결합하는 경우, 유스케이스는 문제 영역과 도메인 헥사곤 내의 비즈니스 규칙보다 SuD와 애플리케이션 헥사곤에 더 큰 의미를 갖는 애플리케이션 특화 활동의 격차를 해소하는 데 중요하다. 유스케이스 측면에서 생각하면, 우리는 헥사고날 아키텍처에서 관심사
		- 유스케이스 작성 방법
		  형식을 따르는 방식으로 실행되는 표준은 유스케이스의 작성 방법에 대한 명확한 경로를 제공한다. 이것은 다른 사람이 작성한 유스케이스가 없는 상태인 임의의 유스케이스 관점을 생각하는 상황을 방지하는 데 도움이 된다. 형식을 갖춘 유스케이스는 다음과 같다.
			- 액터(Actor): 인프라 엔지니어
			- 목표(Goal):에지 라우터에 새로운 네트워크를 추가
			- 범위(Scope): 인프라 부서
			- 트리거(Trigger): 다른 네트워크를 통한 네트워크 액세스를 분리하는 특별한 이유
			- 입력 데이터(input data): 라우터 ID, 네트워크 이름, 주소, CIDR
			- 액션(Action)
				1. 라우터 ID를 찾는다.
				2. 네트워크 주소가 이미 존재하는지 확인한다.
				3. CIDR이 최솟값 아래인지 확인한다.
				4. 이전 검사에서 문제가 없다면 통보된 라우터에 네트워크를 추가한다.
		형식을 갖춘 작성 기법과 간단한 작성 기법 외에, 자동화된 테스트로 직접 사용자의 의도를 코드로 표현 하는 것이 가능하다. 이 방법은 발견(discovery), 형식화(formulation), 자동화(automation)와 관련된 행위 주도 설계(BDD: Behavior Driven Design) 원칙에 의존한다.
	
		소프트웨어 개발 초기 BDD를 사용할 때 비즈니스 아이디어를 검증하기 위해 만든 예제와 테스트를 기반으로 반복적으로 유스케이스를 생성할 기회를 갖게 된다.
		
		현재 Cucumber를 도입하여 테스트를 수행하기 보다는 [걸킨 문법](https://cucumber.io/docs/gherkin/reference/)을 통한 단위테스트로 애플리케이션 헥사곤에 대한 테스트를 수행하고 이후에 성숙도가 올라갔을 경우 이를 도입하는 것이 더 좋은 판단이라고 생각이 된다.
		
		헥사고날 애플리케이션을 개발할 때 제안하는 바는 유스케이스를 구현보다는 추상적 개념으로 설계하는 것이다. 예제에서는 인터페이스를 사용하지만 추상 클래스(abstract classes)를 사용해도 문제가 없다.
			  ![[Screenshot 2024-02-03 at 6.39.47 PM.png]]
			  
	- 입력 포트를 갖는 유스케이스 구현
		헥사고날 아키텍처에는 드라이빙 오퍼레이션과 드리븐 오퍼레이션이라는 개념이 있다. 이러한 분류가 헥사고날 시스템과 상호작용하는 액터를 결정하는 데도 유효하다는 것을 확인했다. 드라이빙 액터는 애플리케이션에 요청을 보내는 사람이며, 드리븐 액터는 애플리케이션에서 액세스하는 외부 컴포넌트를 나타낸다. **드라이빙 액터와 헥사고날 시스템에 의해 노출되는 드라이빙 오퍼레이션 사이의 통신 흐름을 허용하기 위해 입력 포트(기본 포트로도 알려져 있다.)를 사용한다.** 유스케이스는 애플리케이션이 지원해야 하는 동작을 알려주고, ==입력 포트는 이러한 동작 의 수행 방법을 알려준다.== 
		
		입력 포트는 문제 영역에 대한 어떤 특정 항목도 포함되어 있지 않다. 주된 관심사는 도메인 서비스를 통한 내부 호출과 외부 포트를 통한 외부 호출을 조정하고 데이터를 처리하는 것이다. 입력 포트는 오퍼레이션의 실행 순서를 설정하고 도메인 헥사곤이 이해할 수 있는 형식으로 데이터를 제공한다. 
		
		외부 호출은 외부 시스템으로 데이터를 전송하거나 외부 시스템에 데이터를 보관하기 위해 헥사고날 애플리케이션이 수행하는 상호작용이다. 
	- 출력 포트를 이용한 외부 데이터 처리
		출력 포트는 보조 포트(secondary port)로도 알려져 있으며, 외부 데이터를 처리하려는 애플리케이션의 의도를 나타낸다. 여기서는 출력 포트를 통해 시스템이 외부 세계와 통신할 수 있도록 준비한다. 이러한 통신을 허용함으로써 출력 포트를 드리븐 액터와 오퍼레이션에 연결할 수 있다. 드리븐 액터는 외부 시스템이지만 드리븐 오퍼레이션은 이런 시스템과 통신하는 데 사용된다는 것을 기억하자.
		- 리포지토리만 문제가 아니다.
			데이터베이스에서 지속성과 관련된 애플리케이션의 행위를 설명하기 위해 리포지토리(repository)나 데이터 접근 객체(DAO: Data Access Objects) 같은 용어를 사용하는 데 익숙할 수 있다.==헥사고날 애플리케이션에서는 리포지토리를 출력 포트로 대체한다.==
			  
			애노테이션의 사용 자체는 문제가 아니다. 문제는 애노테이션의 사용 목적에 더 많이있다. 애노테이션을 사용하는 목적이 특정 프레임워크에만 있는 기능을 구현하기 위해서라면 소프트웨어는 해당 프레임워크와 결합하게 된다. 대신, 자바 표준 명세에 기반한 기능을 구현하기 위해 애노테이션을 사용하는 것이 목적이라면 소프트웨어가 변경에 더 잘 견디게 만들기 위한 귀중한 노력을 하고 있는 것이다.
			
			==출력 포트의 주된 목표는 데이터를 가져오는 방법을 지정하지 않고 어떤 종류의 데이터가 필요한지 지정 하는 것이다. 이것이 구현이 아닌 인터페이스를 정의하는 이유다.==
		- 어디에 출력 포트를 사용하는가?
			출력 포트는 입력 포트를 가진 유스케이스를 구현할 때 명시적으로 사용된다. 
			
			유스케이스에서 정의되고 입력 포트에 의해 구현되는 오퍼레이션 중 일부 오퍼레이션은 외부 소스에서 데이터를 가져오거나 데이터를 유지하는 역할을 한다. 이것이 유스케이스 목표를 달성하는 데 필요한 데이터를 제공하기 위해 출력 포트가 필요한 이유다.
	- 애플리케이션 헥사곤을 통한 동작 자동화
	  애플리케이션 헥사곤을 구현하는 한 가지 이점은 시스템의 요구사항을 만족시키기 위해 사용해야 하는 기술을 지정할 필요가 없다는 점이다. 물론, 나중에 특정 액티비티를 다룰 때 우리의 삶을 더 쉽게 만들기 위해 개발된 멋진 개발 프레임워크(컨텍스트 및 의존성 주입[CDI: Contexts and Dependency Injection] 메커니즘이 제공하는 객체 수명주기 관리)를 추가하는 것이 가능하다. 그러나 헥사곤 시스 템을 다른 기술과 더 쉽게 통합할 수 있게 만드는 것은 기술적인 세부 사항에 초점을 두지 않는 순수한 방법이다.
	  
	  헥사고날 아키텍처가 제공하는 가능성을 계속해서 탐색하다 보면 개발 프레임워크를 사용하는 것이 소프트웨어 개발의 핵심이 아님을 알게 될 것이다. 대신, 헥사고날 시스템에서 프레임워크는 특정 문제를 해결하기 위해 전략적으로 사용하는 일반적이고 실용적인 라이브러리와 같다. 


04. 외부와 상호작용하는 어댑터 만들기
	- 어댑터 이해
	- 드라이빙 오퍼레이션 허용을 위한 입력 어댑터 사용
		- 입력 어댑터 생성
		- 기반 어댑터
		- REST 입력 어댑터
		- 입력 어댑터 호출하기
	- 다양한 데이터 소스와 통신하기 위한 출력 어댑터 사용
		- 출력 어댑터 생성
		- H2 출력 어댑터
		- 파일 어댑터
		- 출력 어댑터 호출

05. 드라이빙 오퍼레이션과 드리븐 오퍼레이션의 본질 탐색
	- 드라빙 오퍼레이션을 통한 헥사고날 애플리케이션에 대한 요청 호출
		- 웹 애플리케이션을 헥사고날 시스템에 통합
			- 네트워크 추가 페이지 생성
			- 라우터 가져오기 페이지 생성
		- 테스트 에이전트 실행
		- 애플리케이션 간의 헥사고날 시스템 호출
	- 드리븐 오퍼레이션을 통한 외부 리소스 처리