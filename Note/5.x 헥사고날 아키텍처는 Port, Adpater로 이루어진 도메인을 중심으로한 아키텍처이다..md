[[5.x.0 헥사고날 아키텍처의 중요한 세 가지 헥사곤]]
[[5.x.2 헥사고날 아키텍처의 Tradeoff]]

01. 왜 헥사고날 아키텍처인가?
	- 소프트웨어 아키텍처 검토
		단지 동작하는 소프트웨어가 아닌, 쉽게 유지보수할 수 있고 잘 구성된 소프트웨어를 만들려고 하는 경우 소프트웨어를 만들기 위해 도입한 세부사항에 대한 주의와 관심 때문에 어느 정도 소프트웨어를 일종의 예술로 간주할 수 있다. 그러면 이를 소프트웨어 아키텍처에 대한 고결한 정의로 볼 수도 있다.
		
		소프트웨어 아키텍처는 한 사람이 가진 생각의 결실이 되어서는 안 된다. 가이드를 제공하고 기반을 구축해 다른 사람들이 기술적으로 우수한 길로 나아가도록 촉구하는 사람도 있지만, 아키텍처가 진화하고 성숙하기 위해서는 소프트웨어 품질을 개선하기 위한 활동과 관련된 모든 사람과의 협업과 경험이 필요하다. 
		- 보이지 않는 것들
			고객은 그들이 볼 수 있는 것, 비즈니스 기대치를 만족하면서 동작하는 소프트웨어에 관심을 가진다. 그것이 고객이 돈을 지불하는 이유이다. 
			
			그러나 고객이 볼 수 없는 것 또한 어느 정도 중요하다. 이러한 것을 비기능 요구사항이라고 한다. 보안, 유지보수성, 운영 가능성, 그리고 다른 기능과 관련된 것들이다. 고객 관점에서 볼 수 없는 이러한 것들에 적절한 주의를 기울이지 않으면 그것들이 소프트웨어의 목적을 손상시킬 수 있다. 이러한 타협은 미묘하고 점진적으로 발생할 수 있으며, 기술 부채를 포함한 여러 문제의 원인이 된다.
			 
			소프트웨어 아키텍처는 무언가를 올바르게 만드는 것에 관한 것이라고 언급했다. 따라서 이것은 소프트웨어 아키텍처의 관심사 중에서 보이는 것과 보이지 않는 것 모두를 포함해야 함을 의미한다. 고객에게 보이는 것, 문제 영역에 대한 깊은 이해가 필수적이다.
		- 기술 부채
			 워드 커닝햄이 만든 기술 부채라는 용어는 소프트웨어 코드내에 존재하는 불필요한 복잡성이 얼마나 존재하는지를 설명하는 데 사용된다. 이런 불필요한 복잡성을 크러프트라고 한다. 크러프트는 현재 코드와 이상적인 코드와의 차이다. 우리는 소프트웨어 프로젝트에서 기술 부채가 어떻게 나타날 수 있는지에 대해 곧바로 학습할 것이다. 
		- 악순환
			 재정 부채는 갚을수록 계속해서 증가하는 경향이 이다. 재정 부채와 다르게, 기술 부채는 처리하지 않는다고 해도 반드시 드러나지는 않는다. 기술 부채의 증가를 결정하는 것은 소프트웨어의 변경 속도와 특성이다. 그렇기 때문에 빈번하고 복잡한 변경이 있으면 기술 부채가 증가할 가능성이 더 높다. 
			 
			 기술 부채를 통제하지 못하면 결국 과부하된 기술 부채 시스템에 새로운 기능을 추가할 만한 가치가 없게 될 것이다. 그 시점에는 애플리케이션을 포기하고 새로운 애플리케이션을 만들기 시작한다. 그리고 이러한 주기가 반복된다. 따라서 이러한 주기를 깨기 위해서라고 기술 부채를 해결하려는 활동을 촉진해야 한다. 
		- 아키텍처 관련 의사 결정
		 소프트웨어 설계에 있어 중요한 포인트는 시스템 변경의 필요성과 능력이다. 선행 설계에 너무 많은 노력을 들이면, 결국 과도한 엔지니어링으로 인해 솔루션이 비싸질 수 있다. 반대로 설계에 대해 신경을 쓰지 않으면 변경 비용이 증가할 위험이 있다. 익스트림 프로그래밍에서 지적했듯이 설계에 사용된 리소스는 변경을 처리하는 비용을 증가시키지 않고 변경을 수용 가능한 속도로 처리하기 위한 시스템의 요구와 일치해야 한다. 

	- 헥사고날 아키텍처 이해
		 "여러분의 애플리케이션을 UI나 데이터베이스 없이 동작하도록 만드십시오. 그러면 애플리케이션에 대해 자동화된 회귀 테스트를 실행할 수 있고, 데이터베이스를 사용할 수 없을 때도 동작합니다. 그리고 어떤 사용자의 개입 없이도 애플리케이션을 함께 연결할 수 있습니다." - 알리스테어 코크번

		 헥사고날 아키텍처의 주된 아이디어 중 하나는 비즈니스 코드를 기술 코드로부터 분리하는 것이다. 그 뿐만 아니라 기술 측면이 비즈니스 측면에 의존하는지도 확인해 비즈니스 측면이 비즈니스 목표를 달성하는 데 사용되는 기술에 대한 우려 없이도 발전할 수 있게 해야 한다. 도한 관련된 비즈니스 코드에 피해를 주지 않고도 기술 코드를 변경할 수 있어야 한다. 이러한 목표를 달성하려면 비즈니스 코드가 어디에 존재해야 하는지, 기술 문제로부터 격리되고 보호돼야 하는 위치를 결정해야 한다. 이것은 우리의 첫 번째 헥사곤, 즉 도메인 핵사곤을 생성하게 할 것이다. 
		 
		 도메인 헥사곤에서는 소프트웨어가 해결하기를 원하는 핵심 문제를 설명하는 요소들을 결합한다. 해당 헥사곤에서는 DDD를 활용할 수도 있다.
		 
		 또한 도메인 헥사곤에서 나오는 비즈니스 규칙을 사용, 처리하고 조정하는 방법이 필요하다. 이는 애플리케이션 헥사곤이 하는 일이다. 애플리케이션 헥사곤은 비즈니스 측면과 기술 측면 사이에 있으며, 양쪽과 상호작용하는 중개자 역할을 한다. 애플리케이션 헥사곤은 포트와 유스케이스를 활용해 이러한 기능을 수행한다. 
		 
		 프레임워크 헥사곤은 외부 인터페이스를 제공한다. 프레임워크 헥사곤은 애플리케이션 기능의 노출 방법을 결정할 수 있는 곳이다. 예를 들어, 프레임워크 헥사고에서 REST나 gRPC 엔드포인트를 정의한다. 외부 소스에서 무언가를 소비하기 위해 데이터베이스, 메시지 브로커, 또는 다른 시스템에서 데이터를 가져오는 메커니즘을 정의하기 위해 프레임워크 헥사곤을 사용한다. 헥사고날 아키텍처에서는 어댑터를 통해 기술 결정을 구체화한다. 
		 ![[Screenshot 2024-01-29 at 5.42.56 PM.png]]
		  
				
	- 도메인 헥사곤
		 도메인 헥사곤은 실 세계 문제를 이해하고 모델링하는 활동을 나타낸다. 이 임무는 사소한 것이 아니다. 이 작접에 참여하는 개발자들은 도메인 전문가나 해당 도메인 문제를 이미 알고 있는 개발자에게 조언을 구해야 한다. 
		도메인 헥사곤 안에는 중요한 비즈니스 데이터와 규칙에 관련된 엔티티들이 있다. 도메인 헥사곤은 문제 영역을 표현하는 데 유용한 모든 종류의 객체들과 구성된다는 점에 주의하라. 다음 그림은 엔티티와 값 객체를 기반으로 도메인 헥사곤을 나타낸 것이다. 

		- 엔티티
		    엔티티는 좀 더 표현력 있는 코드를 작성하는 데 도움을 준다. 엔티티는 객체를 특징짓는 것은 연속성과 정체성에 대한 감각이다. 
		- 값 객체
		    값 객체는 무언가 고유하게 시별한 필요가 없는 경우는 물론이고, 객체의 정체성보다 속성에 관심을 갖는 경우에도 코드의 표현력을 보완하는 데 도움이 된다. 값 객체를 사용해 엔티티 객체를 구성할 수 있다. 

	- 애플리케이션 헥사곤
	    지금까지 도메인 헥사곤이 비즈니스 규칙을 엔티티와 값 객체로 객체 캡슐하는 방법에 대해 논의 했다. 애플리케이션 헥사곤은 애플리케이션 특화 작접을 추상적으로 처리하는 곳이다. 아직 기술 관심사를 직접 다루지 않기 때문에 추상적인 것을 이야기 한다. 이 핵사곤은 도메인 비즈니스 규칙에 기반한 소프트웨어 사용자의 의도와 기능을 표현한다. 
	    
	    - 유스케이스 : 유스케이스는 도메인 제약사항을 지원하기 위해 시스템의 동작을 소프트웨어 영역 내에 존재하는 애플리케션 특화 오펴레이선을 통해 나타난다. 자바에서 유스케이스는 소프트웨어가 할 수 있는 것을 표현하는 인터페이스로 정의된 추상화로 나타낸다. 
	    - 입력 포트 : 유스케이스가 소프트웨어가 하는 일을 설명하는 인터페이스라면 여전히 유스케이스 인터페이스를 구현해야 한다. 이것이 입력 포트의 역할이다. 애플리케이션 수준에서 유스케이스에 직접 연결되는 컴포넌트가 되기 때문에 입력 포트는 도메인 용어로 소프트웨어의 의도를 구현할 수 있게 한다.
	    - 출력 포트 : 유스케이스가 목표를 달성하기 위해 외부 리소스에서 데이터를 가져와야 하는 상황이 있다. 이것이 출력 포트의 역할이다. 출력 포트는 유스케이스나 입력 포트가 오퍼레이션을 수행하기 위해 어떤 종류의 데이 터를 외부에서 가져와야 하는지를 기술에 구애받지 않고 설명하는 인터페이스로 표현된다. 여기서 출력 포트가 기술에 구애받지 않는다고 말한 것은 예를 들어, 해당 데이터가 특정 관계형 데이터베이스 기술 이나 파일 시스템에서 오는지 신경 쓰지 않기 때문이다. 

	- 프레임워크 헥사곤
		 도메인 헥사곤으로 제한되는 중요한 비즈니스 규칙은 모든 것이 잘 구성된 것처럼 보인다. 다음으로 유스케이스, 입력 포트, 출력 포트를 통해 일부 애플리케이션 특화 오퍼레이션을 다루는 애플리케이션 헥사곤이 뒤따른다. 이제 소프트웨어와 통신할 수 있는 기술을 결정해야 하는 순간이 왔다. 통신은 두 가지 형태로 발생할 수 있다. 하나는 드라이빙(driving) 방식이고 다른 하나는 드리븐(driven) 방식이다. 다음 다이어그램에서 볼 수 있듯이, 드라이버 관점의 경우는 입력 어댑터(Input Adapter)를 사용한다.

		- 드라이빙 오퍼레이션과 입력 어댑터
			 드라이빙 오퍼레이션(Driving operation)은 소프트웨어에 동작을 요청하는 것이다. 예를 들어, 드라이빙 오퍼레이션은 명령행 클라이언트를 갖는 사용자나 사용자를 대신하는 프런트엔드 애플리케이션이될 수 있다. 소프트웨어에 의해 노출된 항목들의 정확성을 검사하는 일부 테스트 스위트가 있을 수 있다. 또는 노출된 일부 소프트웨어 기능과 상호작용이 필요한 대규모 생태계 내의 다른 애플리케이션일 수도 있다. 이러한 통신은 입력 어댑터 상단에 구축된 애플리케이션 프로그래밍 인터페이스(API)를 통해 일어난다.
			 
		- 드리븐 오퍼레이션과 출력 어댑터
			 드라이빙 오퍼레이션의 반대편에는 드리븐 오퍼레이션(Driven operation)이 있다. 이 오퍼레이션은 애플리케이션에서 트리거되고, 외부에서 소프트웨어 요구사항을 충족시키는 데 필요한 데이터를 가져온 다. 일반적으로 드리븐 오퍼레이션은 일부 드라이빙 오퍼레이션에 응답해 발생한다. 상상할 수 있듯 출력 어댑터를 통해서 드리븐 오퍼레이터를 정의한다. 이 어댑터는 그것들을 구현하는 출력 포트와 일치해야 한다.
			 
			 출력 포트는 일부 애플리케이션 특화 작업을 수행하는 데 필요한 데이터의 종류를 알려준다는 점을 기억 하자. 데이터를 어떻게 가져올지 설명하는 것은 출력 어댑터에 달려 있다.

				![[Screenshot 2024-01-30 at 10.12.33 AM.png]]

	- 헥사고날 접근 방식의 장점
		  여러 공급업체와 대규모 프로젝트를 진행해보고, 같은 기반 코드에 기여할 수 있는 새로운 개발자를 데려와 써본 수많은 경험에 비추어 보면, 헥사고날 아키텍처는 조직이 소프트웨어를 구성하는 기본 원칙을 수립하는 데 도움이 된다. 프로젝트를 전환할 때마다 개발자는 이전 프로젝트에서 획득한 헥사고날 원칙에 대해 이미 알고 있기 때문에 소프트웨어가 어떤 구조로 되어 있는지 이해하기 위한 완만한 학습 곡선을 갖게 된다. 이러한 요소는 특히 기술 부채가 적은 소프트웨어가 가져다주는 장기적인 이점과도 관련이 있다.
		  
		변경과 테스트가 쉬운, 유지보수하기 좋은 애플리케이션은 언제나 환영받는다. 이제 헥사고날 아키텍처가 이러한 장점을 얻는 데 어떻게 도움이 되는지 살펴보자.

		- 변경 허용
			헥사고날 아키텍처의 포트와 어댑터라는 특성은 마찰이 적고 기술 변화를 흡수할 준비가 되어 있는 애플리케이션을 위한 아키텍처 원칙을 강력한 이점으로 제공한다
		- 유지보수성
			  알다시피 비즈니스 규칙을 변경해야 경우 유일하게 변경해야 하는 것은 도메인 헥사곤이다. 반면, 아직 애플리케이션에서 지원하지 않는 특정 기술이나 프로토콜을 사용하는 기존 기능을 고객이 트리거할수 있게 허용해야 하는 경우 프레임워크 헥사곤에서 실행할 수 있는 새로운 어댑터를 생성하기만 하면 된다.
		- 테스트 용이성
			  헥사고날 아키텍처의 궁극적인 목표 중 하나는 알리스테어 코크번이 말한 것처럼 UI와 데이터베이스 같은 외부 의존성이 없더라도 개발자가 애플리케이션을 테스트할 수 있게 하는 것이다. 그러나 이것은 헥사고날 아키텍처가 통합 테스트를 무시한다는 의미는 아니다. 이와는 별개로, 헥사고날 아키텍처는 코드의 가장 중요한 부분을 테스트하는 데 필요한 유연성을 제공함으로써 더욱더 계속해서 통합하는 방식을 허용한다. 이는 기술 의존성이 없는 경우에도 마찬가지다.

02. 도메인 헥사곤으로 비즈니스 규칙 감싸기
     문제 영역을 모델링하는 기법 중에서 도메인 주도 설계(DDD)가 비즈니스에 대한 지식을 전달하는 매개체로 소프트웨어 코드를 강조하는 프로젝트에서 광범위하게 채택된다. 핵심 문제 영역을 구성하는 것과 부차적인 것을 분리하려고 한다는 점에서 DDD는 기술 코드를 비즈니스 코드에서 분리하는 헥사고날 아키텍처의 목표를 지원하는 적합한 방법이다.
     
	 - 엔티티를 활용한 문제 영역 모델링
		 DDD에서는 코드를 작성하기 전에 개발자와 비즈니스를 깊게 이해하는 도메인 전문가 사이에서 많은 논의가 있어야 한다. 이러한 논의는 개발자와 도메인 전문가 사이의 브레인스토밍에 기반한 지식 크런칭(knowledge crunching) 과정을 통해 귀중한 정보를 제공한다. 그다음, 해당 지식은 보편 언어 (Ubiquitous Language)를 통해 통합된다. 이 언어는 프로젝트와 관련된 모든 사람 사이에서 공용어 (lingua franca) 역할을 하고, 문서, 일상 대화, 코드에도 존재하게 된다.
		 
		 엔티티를 다룰 때는 코드를 읽는 것만으로 비즈니스에 대해 얼마나 많이 배울 수 있는지 항상 유념해야 한다. 진정으로 가치 있는 것은 보편 언어를 계속해서 발전시키고 코드가 그 언어로 말할 수 있도록 지식 크런칭 기법을 사용할 때 발생하기 때문이다. 이것은 실제로 유의미한 동작을 포착하고 단순 데이터 객체 이상이 되는 풍부한 엔티티의 기반이 된다.
		 
		- 도메인 엔티티의 순수성
			 문제 영역을 모델링할 때 주된 초점은 가능한 한 정확하게 실제 시나리오를 코드로 변환하는 것이다. 문제 영역에 대한 모델링 활동은 수익을 얻고 소프트웨어에 의존하는 조직 전반의 성공을 결정하는 데 중요하다. 비즈니스 요구사항을 이해하고 코드로 변환하는 데 실패하면 결과적으로 비용의 손실이 발생할 수밖에 없다. 
			 
			 문제 영역 모델링의 핵심은 엔티티를 만드는 것이다. 엔티티가 비즈니스 요구사항과 밀접한 관계를 가져야 하기 때문에 이러한 엔티티를 기술적인 요구사항으로부터 보호하기 위해 노력해야 한다. 비즈니스 관련 코드와 기술 관련 코드가 혼동되는 것을 방지하기 위해 노력해야 한다. 여기서 기술적이라는 말은 소프트웨어 맥락에서만 존재하고 의미가 있다는 것을 말한다. 
			 
			 **도메인 엔티티는 비즈니스 관심사만 처리한다는 점에서 순수해야 한다. 기술에 특화된 경우라면, 다음 장에서 살펴보겠지만 포트, 유스케이스, 어댑터를 활용할 수 있는 특권을 갖고 있다.**
		- 관련 엔티티
			 비즈니스 규칙과 비즈니스 데이터라는 두 요소의 존재는 관련 엔티티의 특징을 결정한다. 빈약한 도메인 모델(anemic domain model)에서 나오는 엔티티 객체는 데이터는 있지만 동작은 부족하다. 동작과 데이터가 결합되지 않으므로, 빈약한 도메인 모델은 객체지향 프로그래밍의 본질에 반한다. 도메인 객체에 동작이 존재하지 않는 경우에는 엔티티가 무엇을 해야 하는지를 완전하게 파악하기 위해 다른 곳으로 가야 한다. 그로 인해 기반 코드가 커지면 금방 부담될 만한 번거로운 과부하가 생긴다.
		- UUID를 이용한 식별자 정의
			 식별자(ID: Identifier)의 중복 생성 및 방지를 위해 데이터베이스 시퀀스 메커니즘에 의존하는 식별자 생성 기법에 익숙한 사람도 있을 것이다. 이러한 책임을 데이터베이스에 위임하는 것이 편리하지만 그렇게 함으로써 소프트웨어의 중요 부분을 외부 시스템과 결합하게 된다.
			 
			 UUID는 조심해서 써야 한다. 데이터 소스가 관계형 데이터베이스인 경우에는 성능 문제가 발생할 수있다. UUID는 문자열이기 때문에 관계형 데이터베이스에서 제공하는 자동 생성된 ID로 만들어진 정수 보다 더 많은 메모리를 소비한다. UUID를 사용하면 데이터베이스의 크기와 인덱스 관리에 상당한 영향을 줄 수 있다. 공짜 점심은 없다. 이처럼 기술에 구애받지 않는 ID 생성 솔루션에 컴퓨터 리소스를 비용 으로 지불해야 한다.
			 
			 엔티티는 헥사고날 아키텍처의 일급 객체(first-class citizen) 다.
	- 값 객체를 통한 서술력 향상
		 도메인 주도 설계 구현에서는 문제 영역에서 사물을 측정하고, 수량화하거나 서술하기 위해 값 객체를 사용해야 한다는 점을 상당히 잘 지적했다. 예를 들어, long이나 int 형 값 대신 값 객체를 통해 ID속성을 기술할 수 있다. double이나 big decimal 속성을 특정 값 객체로 감싸서 수량화를 좀 더 명확하게 표현할 수 있다. 
		  
		 문제 영역을 모델리하기 위해 프로그래밍 언어의 내장 타입만 사용하는 것으로는 충분하지 않다. 시스템의 본질과 목적을 더욱 명확하게 하기 위해 이러한 내장 타입, 심지어 우리가 생성한 타입도 잘 정의된 객체로 감싸야 한다. 
		  
		 의미를 전달하려는 이 같은 노력은 값 객체에 대한 다음 두 가지 기본 특성을 기반으로 한다. 
		  
		- 값 객체는 불편이다. 
		- 값 객체는 식별자를 갖지 않는다. 
		
	- 애그리게잇을 통한 일관성 보장
		  엔티티와 값 객체의 그룹이 함께 전체적인 개념을 설명하는 경우에는 어떻게 할까? 이런 상황에서는 애그리게잇을 사용해야 한다. 이때 애그리게잇 내부의 객체들은 일관되고 격리된 방식으로 동작한다. 이러한 일관성을 달성하려면 애그리게잇 객체에 대한 모든 변경은 해당 애그리게잇에 부과되는 변경 사항에 따라 결정되는 것이 보장돼야 한다. 
		  
		 애그리게잇은 객체의 데이터와 동작을 조정하는 오케스트레이터와 같다. 그러자면 애그리게잇 영역과 상호작용할 진입점을 정의해야 한다. 이러한 진입점은 애그리게잇 루트로 알려져 있으며, 애그리게잇의 일부인 엔티티와 값 객체들에 대한 참조를 유지한다. 애그리게잇이 제공하는 바운더리를 통해 바운더리 내부의 객체가 수행하는 오퍼레이션에서 더 나은 일관성을 보장할 수 있게 된다. 
		 
		 성능과 확장성 관점에서 항상 애그리게잇을 가능한 한 작게 유지하기 위해 노력해야 한다. 일반적으로 작은 애그리게잇은 애그리게잇 루트로 동작하는 엔티티와 다른 값 객체들을 포함한다. 두 개의 서로 다른 애그리게잇이 상호작용하게 만드는 방법은 애그리게잇 루트를 사용하는 것이다. 
	- 도메인 서비스 활용
		 애그리게잇 내부의 객체들은 일관되고 격리된 방식으로 동작한다. 이러한 일관 성을 달성하려면 애그리게잇 객체에 대한 모든 변경은 해당 애그리게잇에 부과되는 변경 사항에 따라 결정되는 것이 보장돼야 한다. 도메인 서비스는 엔티티와 값 객체 클래스가 문제 영역을 따라 필요 이상으로 많은 기능을 가지고 너무 커지는 것을 방지하기 위한 가치있는 활동이기도 한다.

	- 정책 패턴과 명세 패턴을 활용한 비즈니스 규칙 처리
		 시스템이 가지고 있는 가장 큰 가치 중 하나는 **성문화된 비즈니스 규칙**이다. 이러한 규칙은 실제 문제를 이해하고, 이해한 바를 동작하는 소프트웨어로 변환하기 위한 필수적인 노력을 나타낸다. 
		  
		정책 패턴과 명세 패턴은 비즈니스 규칙을 더 잘 구조화하기 위한 두 가지 패턴이다. 
		
		정책은 전략으로도 알려져 있으며, 코드 블록으로 문제 여역의 일부를 캡슐화하는 패턴이다. 전략 패턴에 익숙한 사람들은 알고리즘이라는 용어를 캡슐화된 코드 블록을 설명하는 데 사용할 수 있다. 정책의 주된 특성은 제공된 데이터에 대해 어떤 작업이나 처리를 한다는 점이다. 정책은 커플링을 피하기 위해 의도적으로 엔티티와 값 객체를 분리해 유지한다. 이러한 디커플링은 직접적인 영향이나 부작용 없이 한 부분을 발전시키는 잘 알려진 혜택을 적용한다. 
		
		반면, [명세(Specification)](https://medium.com/@pawel_klimek/domain-driven-design-specification-pattern-82867540305c)는 객체의 특성을 보장하는 데 사용되는 조건(condition)이나 프레디케이트(predicate)와 같다. 그러나 명세의 특징은 단순한 논리적인 연산자보다는 더 표현적인 방법으로 프레디케이트를 캡슐화한다는 것이다. 이러한 명세들을 캡슐화하면 재사용할 수 있고 함께 결합해서 문제 영역을 더 잘 표현할 수 있다.
		
		함께 사용한다면 정책과 명세는 코드 전반에 걸쳐 비즈니스 규칙의 견고성과 일관성을 향상시키는 믿을 만한 기법이다. 명세는 정책에 적합한 개체만 처리되는 것을 보장한다. 우리는 정책을 통해 다양하면서도 손쉽게 변경할 수 있는 알고리즘들을 자유자재로 활용할 수 있다. 

	- POJO를 통한 비즈니스 규칙 정의
	    POJO는 일반적인 자바 객체에 불과하기 때문에 매력적이다. 사용자 정의 라이브러리와 프레임워크가 아닌 자바 표준 API만 다루기 때문에 이해하기 쉽다. 이것은 POJO를 개발자 친화적인 객체로 만들며, 애플리케이션의 여러 부분에서 이해하고 재사용하기가 더 쉽다.

03. 포트와 유스케이스를 통한 동작 처리
	- 유스케이스를 통한 소프트웨어 동작 표현
		소프트웨어 시스템은 사용자나 다른 소프트웨어 시스템이 정의한 목표를 달성하기 위해 함께 동작하는 일련의 행위 집합에 불과하다. 다시 말해, 소프트웨어의 동작은 단독, 혹은 다른 소프트웨어 동작과 결합해 가치 있는 소프트웨어 목표를 실현하는 데 기여하는 의미 있는 행동이다. 이러한 목표는 사용자나 시스템이 관심을 갖고 표현하는 요구사항과 밀접하게 연결되어 있다.
		
		다이어그램 간의 관계를 통해 시스템의 상위 수준 뷰를 설명하는 UML과 달리, 유스케이스는 SuD 행위의 상세한 글로 작성된 디스크립션을 제공하는 심층 분석을 수행한다. 유스케이스는 SuD 목표, 목표를 충족하기 위한 수단이나 행위, 가능한 실패 시나리오와 이들이 발생하는 경우에 수행해야 할 작업을 설정하는 귀중한 기법이다. DDD 기법과 결합하는 경우, 유스케이스는 문제 영역과 도메인 헥사곤 내의 비즈니스 규칙보다 SuD와 애플리케이션 헥사곤에 더 큰 의미를 갖는 애플리케이션 특화 활동의 격차를 해소하는 데 중요하다. 유스케이스 측면에서 생각하면, 우리는 헥사고날 아키텍처에서 관심사
		- 유스케이스 작성 방법
		  형식을 따르는 방식으로 실행되는 표준은 유스케이스의 작성 방법에 대한 명확한 경로를 제공한다. 이것은 다른 사람이 작성한 유스케이스가 없는 상태인 임의의 유스케이스 관점을 생각하는 상황을 방지하는 데 도움이 된다. 형식을 갖춘 유스케이스는 다음과 같다.
			- 액터(Actor): 인프라 엔지니어
			- 목표(Goal):에지 라우터에 새로운 네트워크를 추가
			- 범위(Scope): 인프라 부서
			- 트리거(Trigger): 다른 네트워크를 통한 네트워크 액세스를 분리하는 특별한 이유
			- 입력 데이터(input data): 라우터 ID, 네트워크 이름, 주소, CIDR
			- 액션(Action)
				1. 라우터 ID를 찾는다.
				2. 네트워크 주소가 이미 존재하는지 확인한다.
				3. CIDR이 최솟값 아래인지 확인한다.
				4. 이전 검사에서 문제가 없다면 통보된 라우터에 네트워크를 추가한다.
		형식을 갖춘 작성 기법과 간단한 작성 기법 외에, 자동화된 테스트로 직접 사용자의 의도를 코드로 표현 하는 것이 가능하다. 이 방법은 발견(discovery), 형식화(formulation), 자동화(automation)와 관련된 행위 주도 설계(BDD: Behavior Driven Design) 원칙에 의존한다.
	
		소프트웨어 개발 초기 BDD를 사용할 때 비즈니스 아이디어를 검증하기 위해 만든 예제와 테스트를 기반으로 반복적으로 유스케이스를 생성할 기회를 갖게 된다.
		
		현재 Cucumber를 도입하여 테스트를 수행하기 보다는 [걸킨 문법](https://cucumber.io/docs/gherkin/reference/)을 통한 단위테스트로 애플리케이션 헥사곤에 대한 테스트를 수행하고 이후에 성숙도가 올라갔을 경우 이를 도입하는 것이 더 좋은 판단이라고 생각이 된다.
		
		헥사고날 애플리케이션을 개발할 때 제안하는 바는 유스케이스를 구현보다는 추상적 개념으로 설계하는 것이다. 예제에서는 인터페이스를 사용하지만 추상 클래스(abstract classes)를 사용해도 문제가 없다.
			  ![[Screenshot 2024-02-03 at 6.39.47 PM.png]]
			  
	- 입력 포트를 갖는 유스케이스 구현
		헥사고날 아키텍처에는 드라이빙 오퍼레이션과 드리븐 오퍼레이션이라는 개념이 있다. 이러한 분류가 헥사고날 시스템과 상호작용하는 액터를 결정하는 데도 유효하다는 것을 확인했다. 드라이빙 액터는 애플리케이션에 요청을 보내는 사람이며, 드리븐 액터는 애플리케이션에서 액세스하는 외부 컴포넌트를 나타낸다. **드라이빙 액터와 헥사고날 시스템에 의해 노출되는 드라이빙 오퍼레이션 사이의 통신 흐름을 허용하기 위해 입력 포트(기본 포트로도 알려져 있다.)를 사용한다.** 유스케이스는 애플리케이션이 지원해야 하는 동작을 알려주고, ==입력 포트는 이러한 동작 의 수행 방법을 알려준다.== 
		
		입력 포트는 문제 영역에 대한 어떤 특정 항목도 포함되어 있지 않다. 주된 관심사는 도메인 서비스를 통한 내부 호출과 외부 포트를 통한 외부 호출을 조정하고 데이터를 처리하는 것이다. 입력 포트는 오퍼레이션의 실행 순서를 설정하고 도메인 헥사곤이 이해할 수 있는 형식으로 데이터를 제공한다. 
		
		외부 호출은 외부 시스템으로 데이터를 전송하거나 외부 시스템에 데이터를 보관하기 위해 헥사고날 애플리케이션이 수행하는 상호작용이다. 
	- 출력 포트를 이용한 외부 데이터 처리
		출력 포트는 보조 포트(secondary port)로도 알려져 있으며, 외부 데이터를 처리하려는 애플리케이션의 의도를 나타낸다. 여기서는 출력 포트를 통해 시스템이 외부 세계와 통신할 수 있도록 준비한다. 이러한 통신을 허용함으로써 출력 포트를 드리븐 액터와 오퍼레이션에 연결할 수 있다. 드리븐 액터는 외부 시스템이지만 드리븐 오퍼레이션은 이런 시스템과 통신하는 데 사용된다는 것을 기억하자.
		- 리포지토리만 문제가 아니다.
			데이터베이스에서 지속성과 관련된 애플리케이션의 행위를 설명하기 위해 리포지토리(repository)나 데이터 접근 객체(DAO: Data Access Objects) 같은 용어를 사용하는 데 익숙할 수 있다.==헥사고날 애플리케이션에서는 리포지토리를 출력 포트로 대체한다.==
			  
			애노테이션의 사용 자체는 문제가 아니다. 문제는 애노테이션의 사용 목적에 더 많이있다. 애노테이션을 사용하는 목적이 특정 프레임워크에만 있는 기능을 구현하기 위해서라면 소프트웨어는 해당 프레임워크와 결합하게 된다. 대신, 자바 표준 명세에 기반한 기능을 구현하기 위해 애노테이션을 사용하는 것이 목적이라면 소프트웨어가 변경에 더 잘 견디게 만들기 위한 귀중한 노력을 하고 있는 것이다.
			
			==출력 포트의 주된 목표는 데이터를 가져오는 방법을 지정하지 않고 어떤 종류의 데이터가 필요한지 지정 하는 것이다. 이것이 구현이 아닌 인터페이스를 정의하는 이유다.==
		- 어디에 출력 포트를 사용하는가?
			출력 포트는 입력 포트를 가진 유스케이스를 구현할 때 명시적으로 사용된다. 
			
			유스케이스에서 정의되고 입력 포트에 의해 구현되는 오퍼레이션 중 일부 오퍼레이션은 외부 소스에서 데이터를 가져오거나 데이터를 유지하는 역할을 한다. 이것이 유스케이스 목표를 달성하는 데 필요한 데이터를 제공하기 위해 출력 포트가 필요한 이유다.
	- 애플리케이션 헥사곤을 통한 동작 자동화
	  애플리케이션 헥사곤을 구현하는 한 가지 이점은 시스템의 요구사항을 만족시키기 위해 사용해야 하는 기술을 지정할 필요가 없다는 점이다. 물론, 나중에 특정 액티비티를 다룰 때 우리의 삶을 더 쉽게 만들기 위해 개발된 멋진 개발 프레임워크(컨텍스트 및 의존성 주입[CDI: Contexts and Dependency Injection] 메커니즘이 제공하는 객체 수명주기 관리)를 추가하는 것이 가능하다. 그러나 헥사곤 시스 템을 다른 기술과 더 쉽게 통합할 수 있게 만드는 것은 기술적인 세부 사항에 초점을 두지 않는 순수한 방법이다.
	  
	  헥사고날 아키텍처가 제공하는 가능성을 계속해서 탐색하다 보면 개발 프레임워크를 사용하는 것이 소프트웨어 개발의 핵심이 아님을 알게 될 것이다. 대신, 헥사고날 시스템에서 프레임워크는 특정 문제를 해결하기 위해 전략적으로 사용하는 일반적이고 실용적인 라이브러리와 같다. 


04. 외부와 상호작용하는 어댑터 만들기
    사용자와 다른 시스템이 애플리케이션과 상호작용할 수 있도록 입력 어댑터를 정의할 수 있다. 같은 방법으로 헥사고날 애플리케이션에서 생성된 데이터를 변환하고 외부 시스템과 통신하기 위한 출력 어댑터도 정의할 수 있다. 입력 어댑터와 출력 어댑터 모두 프레임워크 헥사곤의 가장 끝부분에 있는 것을 볼수 있다.
    ![[Screenshot 2024-02-13 at 9.25.25 AM.png]]

	또한 아래와 같이 어댑터는 프레임워크 헥사곤의 끝 단에 있는 것을 알 수 있다. 
	![[Screenshot 2024-02-13 at 9.26.39 AM.png]]
	
	- 드라이빙 오퍼레이션 허용을 위한 입력 어댑터 사용
	  [[5.m 진화적인 아키텍처는 기업의 지속적인 생존에서 필수이다.#^d9aeea|모든 것이 항상 변하는 지금과 같은 상황]]에서는 소프트웨어를 개발할 때 발생하는 우려 사항 중 하나는 어떻게 시스템이 계속되는 기술적인 변화를 맞이하면서도 유의미하고 수익성을 유지하느냐다. 비즈니스 규칙과 기술적 세부사항이 연결되도록 시스템이 설계된 경우 새로운 기술의 통합은 상당한 양의 리팩터링 없이는 쉽지 않을 것이다. 헥사고날 아키텍처에서 입력 어댑터는 소프트웨어를 다른 기술들과 호환되게 만드는 요소다.
	  
	  헥사곤 외부에는 헥사곤 애플리케이션과 상호작용하는 사용자나 시스템이 있을 수 있다. 이러한 사용 자나 시스템을 가리켜 애플리케이션 유스케이스를 형성하는 중추적인 역할을 하는 주요 액터(primary actor)라고 한다. 주요 액터와 헥사고날 애플리케이션 사이의 상호작용은 입력 어댑터를 통해 일어난다. 이러한 상호작용은 드라이빙 오퍼레이션으로 정의된다. 주요 액터가 이들을 드라이브하고, 헥사고날 시스템의 상태와 행위를 시작하게 하고 영향을 준다는 의미에서 드라이빙으로 표현한다.
		- 입력 어댑터 생성
		  입력 포트는 유스케이스의 목표를 달성하기 위해 입력 포트가 수행하는 오퍼레이션의 수행 방법을 지정해 유스케이스를 구현하는 수단이다. 입력 포트 객체는 오퍼레이션을 수행하기 위해 야콥슨(1992)의 《객체지향 소프트웨어 공학》에서 자극(stimulus)이라 부르는 것을 수신해야 한다. 이 자극은 다른 것을 호출하는 객체에 지나지 않는다. 입력 포트 객체는 입력 어댑터가 보낸 자극을 통해 오퍼레이션을 수행 하는 데 필요한 모든 데이터를 수신한다. 그러나 입력 데이터를 도메인 헥사곤과 호환되는 형식으로 변환하기 위해 이 단계에서 최종적인 변환이 발생할 수 있다.
		  
		- 기반 어댑터
		  기반 어댑터는 어댑터와 관련된 입력 포트와 통신을 위한 ==표준 오퍼레이션을 제공==한다. 이 경우 RouterID 와 Network 객체를 만드는 데 필요한 매개변수를 수신하기 위해 addNetworkToRouter 어댑터 메서드를 사용한다. 이 객체들은 라우터에 네트워크를 추가하는 유스케이스 오퍼레이션을 시작하는 데 사용 된다. 이러한 매개변수는 HTTP 요청이나 STDIN 을 갖는 셸/콘솔과 같은 다양한 소스로부터 올 수 있다. 그러나 매개변수들이 addNetworkToRouter 메서드에 도달하면 같은 방식으로 처리된다.
		  
		  당연하게 기반 어댑터는 유스케이스를 참고할 뿐 직접적으로 입력 포트를 참조하지 않는다. 이것은 기본적인 원칙이다. 구상 클래스와는 직접적인 의존을 갖게 하지 않는 것이 유리보수가 쉬운 프로그램을 만드는 중요한 습관 가운데 하나이다.

	- 다양한 데이터 소스와 통신하기 위한 출력 어댑터 사용
	  객체지향 언어 외에도 엔터프라이즈 소프트웨어는 데이터를 획득하고 유지하는 방법에 의존한다. 예를 들어, 데이터베이스나 메시지 큐, 또는 파일 서버 같은 데이터 소스와 통합되지 않은 시스템은 상상 하기가 어렵다. 컴퓨팅 분야에 있어 무언가를 저장해야 하는 필요성은 항상 존재했다. 그러나 문제는 이러한 요구가 전체 소프트웨어 구조에 영향을 주고 지시하는 방식이다.
	  
	  데이터베이스 외에도 데이터 처리에 대한 소프트웨어 요구사항을 만족시키는 다른 데이터 소스가 사용 되었다. 몇 가지 예를 들면, 파일 시스템과 메시지 브로커, 디렉터리 기반 스토리지(LDAP), 메인프레임 스토리지는 소프트웨어가 데이터를 처리할 수 있는 몇 가지 방법이다. 클라우드 컴퓨팅 세계에서는 데이 터를 주고받기 위해 시스템을 다양한 기술과 통합하는 것이 더 자연스러워지고 있다. 이제 시스템은 이기종 기술이라는 맥락에서 스스로를 이해할 수 있어야 하기 때문에 이러한 통합은 소프트웨어 개발에서몇 가지 문제를 나타낸다. 이러한 상황은 이질성을 촉진하는 마이크로서비스 같은 아키텍처에서는 더 악화된다. 이러한 문제를 해결하려면 기술적으로 이기종 환경의 변화를 극복하는 기술이 필요하다. 

		- 출력 어댑터 생성
		  헥사고날 아키텍처에서 출력 어댑터의 역할은 드리븐 오퍼레이션을 처리하는 것이다. 드리븐 오퍼레이션은 일부 데이터를 보내거나 받기 위해 외부 시스템과 상호작용하는 헥사고날 애플리케이션 자체에 의해 시작된 오퍼레이션이라는 점을 기억하자. 이러한 드리븐 오퍼레이션은 유스케이스를 통해 서술되며, 유스케이스의 입력 포트 구현에 있는 오퍼레이션에 의해 트리거된다. 유스케이스에서 외부 시스템에 있는 데이터를 처리할 필요성이 언급될 수 있다. 이것은 유스케이스에서 외부 시스템에 있는 데이터를 처리해야 하는 필요 성을 이야기할 때마다 헥사고날 애플리케이션이 이러한 요구사항을 만족하기 위해 적어도 하나 이상의 출력 어탭터와 출력 포트가 필요하다는 것을 의미한다. 
	

05. 드라이빙 오퍼레이션과 드리븐 오퍼레이션의 본질 탐색
    드라이빙 오퍼레이션과 드리븐 오퍼레이션의 본질은 헥사고날 애플리케이션과 상호작용하는 외부요소를 나타낸다는 것에 있다. 먼저는 드라이빙 관점에서 프런트엔드 애플리케이션이 헥사고날 시스템의 행위를 유도하는 주요 액터로 생동하는 방법을 살펴볼 것이다. 드리븐 관점에서는 메시지 기반 시스템이 헥사고날 시스템에 의해 구동되게 하려면 무엇이 필요한지에 대해 배울 것이다.

	- 드라빙 오퍼레이션을 통한 헥사고날 애플리케이션에 대한 요청 호출
	 시스템이 자급자족한다는 것은 상상할 수 없는 일이다. 즉, 아무도 시스템과 상호작용하지 않고 시스템도 다른 사용자나 시스템과 상호작용하지 않는다는 것은 상상조차 할 수 없다. 이러한 방식은 모든 컴퓨터 시스템에는 입력 및 출력 오퍼레이션이 있다고 가정하는 컴퓨터 아키텍처(폰 노이만, 1940)의 근간에 위배된다. 실제로 데이터를 수신하지도 않고 결과를 만들어 내지도 않는 유용한 소프트웨어 프로그램을 상상하기는 어렵다.
    
     헥사고날 아키텍처 시점으로 보면 시스템의 입력 측은 드라이빙 오퍼레이션에 의해 제어된다. 사실상 이것들은 헥사고날 애플리케이션의 동작을 시작하게 하고 유도하기 때문에 드라이빙 오퍼레이션으로 불린다.
	- 애플리케이션 간의 헥사고날 시스템 호출
	  특히 MSA에서는 여러 다른 헥사곤들이 Input, Output 가 연관을 가질 수 있다. MSA에 대한 많은 미신 가운데 하나는 여러 서비스들이 Restful API로 통신을 하며 시스템을 만들어나간다는 것이다. 이러한 구현 방법은 시스템의 가용성을 크게 해지며, 복잡석을 크게 증가시킨다. 특히 직접적인 의존관계는 이후 프로그램의 유지보수에 매우 좋지 않은 영향을 미친다. 가능하면 직접 적인 방식의 의존은 피하도록 시스템을 설계하도록 한다. 
	- 드리븐 오퍼레이션을 통한 외부 리소스 처리
	  드라이빙 오퍼레이션은 헥사고날 시스템의 행위를 유도하는 주요 액터의 요청에서 비롯된다. 반면, 드리븐 오퍼레이션은 헥사고날 시스템에 의해 데이터베이스나 다른 시스템 같은 보조 액터 쪽으로 시작된 요청이다. 다음 다이어그램은 드리븐 오퍼레이션을 갖는 드리븐 측면을 보여준다.
		- 데이터 지속성
		  데이터 지속성을 기반으로 하는 드리븐 오퍼레이션이 가장 일반적이다. 
		- 메시징과 이벤트
		  모든 시스템이 동기식 통신에 의존하는 것은 아니다. 상황에 따라 애플리케이션의 런타임 흐름을 방해하지 않고 특정 이벤트를 트리거하고 싶을 수도 있다.
		 - Mock Server
		   일반적인 소프트웨어 개발 방법은 개발, QA, 운영 같이 다양한 환경을 갖는 것이다. 테스트 장애를 극복하기 위해 어떤 도구는 애플리케이션 엔드포인트와 그것들의 응답을 시뮬레이션하기도 한다. 이러한 도구는 모의 솔루션(mock solution)으로 알려져 있으며, 다양한 모양과 형태로 제공 된다. 애플리케이션에 필요한 응답과 서비스 엔드포인트를 수동으로 흉내(mock) 낼 수 있다. 그러나 이러한 작업은 사소한 것이 아니며 상당한 노력이 들어갈 수도 있다. 물론, 이러한 지저분한 작업을 대신 수행하고 논리에만 집중할 수 있게 해주는 정교한 도구가 있다. 이것이 바로 모의 서버(mock server) 의 역할이다.

06. 도메인 헥사곤 만들기	
    도메인 헥사곤은 헥사고날 애플리케이션의 개발을 시작하는 곳이다. 도메인을 기반으로 다른 모든 헥사곤을 도출한다. 핵심적인 기본 비즈니스 로직은 도메인 헥사곤에 있기 때문에 도메인 헥사곤은 헥사고날 시스템의 두뇌라고 할 수 있다.
	- 문제 영역 이해
	  문제 영역은 글이나 다이어그램으로 충분히 정의되어 있어야 한다. 이것은 도메인의 문제 영역에 대한 탐구를 말하는 것으로 분석 모델을 통한 요구사항 정의와는 다른 것이다. 
	- 값 객체 정의
	  객체는 더 정교한 값 객체와 가장 중요한 엔티티를 만드는 데 사용되는 원자재인 기반 요소이므로 먼저 값 객체를 생성하는 것으로 시작하기를 권장한다. 이제 도메인 헥사곤을 생성하기 위해 앞 절에서 생성한 도메인 헥사곤 모듈에 모든 값 객체 클래스를 추가할 것이다. 값 객체를 정의하려면 다음과 같은 단계를 따른다.

07. 애플리케이션 헥사곤 만들기
    시스템 기능을 더욱 잘 보여주기 위해 추천하는 방법 중 하나는 기능과 시나리오 같은 개념을 사용해 시스템의 동작을 설명하는 행위주도 개발(BDD) 기술인 큐컴버를 사용하는 것이다. 따라서 애플리케이션 헥사곤의 경우 헥사고날 시스템의 유스케이스를 만들기 위해 큐컴버를 사용한다.
	- 애플리케이션 헥사곤 생성
	  애플리케이션 헥사곤은 도메인 헥사곤을 통한 내부 요청과 프레임워크 헥사곤을 통한 외부 요청을 조정 한다. 여기서는 도메인 헥사곤과 포트, 유스케이스를 제공하는 도메인 모델을 기반으로 시스템의 기능을 생성한다. ==애플리케이션 헥사곤에서는 제약조건이나 비즈니스 규칙을 정의하지 않는다. 애플리케이션 헥사곤의 목표는 헥사고날 시스템에서 데이터 흐름을 정의하고 제어하는 것이다.==

	- 유스케이스 정의
	  유스케이스를 글 형식과 코드 형식으로 모두 표현하기 위해, 기술에 익숙하지 않은 사람도 코드에 존재 하는 유스케이스를 파악할 수 있게 해주는 귀중한 도구인 [큐컴버](https://medium.com/techinpieces/building-web-applications-using-spring-cucumber-and-swagger-8e44b0f2bc73)를 사용한다. 기능과 시나리오 같은 큐컴버 개념을 통해 따라하기 쉬운 유스케이스 디스크립션을 만들 수 있다. 큐컴버를 사용해 구성한 유스케이스 디스크립션은 유스케이스 인터페이스를 개발하기 위한 참고서 역할을할 수 있다.

		-  디스크립션 작성의 예
			```
			@RouterAdd
			Feature: 코어 라우터에 에지 라우터를 추가할 수 있는가?
			Scenario: 코어 라우터에 에지 라우터 추가 Given 에지 라우터가 있다 And 코어 라우터가 있다 Then 코어 라우터에 에지 라우터를 추가한다
			Scenario: 또 다른 코어 라우터에 코어 라우터를 추가한다 Given 코어 라우터가 있다 And 또 다른 코어 라우터가 있다 Then 코어 라우터에 이 코어 라우터를 추가한다		
			```
		- 유스케이스 인터페이스 작성의 예
		  유스케이스는 정말로 usecase 이다. actor 관점이 잘 표현이 되도록 작성을 해야 한다.
		```java
		import dev.davivieira.topologyinventory.domain.vo.IP;
		import dev.davivieira.topologyinventory.domain.vo.Id;
		import dev.davivieira.topologyinventory.domain.vo.Location;
		import dev.davivieira.topologyinventory.domain.vo.Model;
		import dev.davivieira.topologyinventory.domain.vo.RouterType;
		import dev.davivieira.topologyinventory.domain.vo.Vendor;
		
		public interface RouterManagementUseCase {
			Router createRouter(Vendor vendor, Model mode, IP ip, Location location, RouterType routerType);
			CoreRouter addRouterToCoreRouter(Router router, CoreRouter coreRouter);
			Router removeRouterFromCoreRouter(Router router, CoreRouter coreRouter);
			
			Router retrieveRouter(Id id);
			Router persistRouter(Router router);
		}
		```

	- 입력 포트를 갖는 유스케이스 구현
	  입력 포트는 애플리케이션 헥사곤의 중심 요소다. 도메인 헥사곤과 프레임워크 헥사곤 사이의 간극을 입력 포트를 통해 메우기 때문에 입력 포트는 중요한 통합 역할을 한다. 외부 데이터는 출력 포트에서 가져 온다. 그리고 출력 포트를 사용해 해당 데이터를 도메인 헥사곤으로 전달할 수 있다. 도메인 헥사곤의 비즈니스 로직이 데이터에 적용되면 애플리케이션 헥사곤은 프레임워크 헥사곤의 출력 어댑터 중 하나에 도달할 때까지 해당 데이터를 다운스트림으로 이동시킨다.
	  
	  UseCase Interface 에 대한 구현은 Input에서 수행하도록 한다. 
		- 애플리케이션 헥사곤 테스트
		  BDD로 정의된 테스트의 구현은 아래와 같이 하도록 한다. 
		```java
		import io.cucumber.junit.Cucumber;
		import io.cucumber.junit.CucumberOptions;
		import org.junit.runner.RunWith;

		@RunWith(Cucumber.class)
		@CucumberOptions(
			plugin = {"pretty", "html:target/cucumber-result}
		)
		public class ApplicationTest{
			@Given("I have an edge router")
			public void assert_edge_router_exists(){
				edgeRouter = (EdgeRouter)
				this.routerManagementUseCase.createRouter(Vendor.HP, Model.XYZ0004, IP.fromAddress("20.0.0.1"), locationA, EDGE);
				assertNotNull(edgeRouter);
			}
			
			@And("I have a core router")
			public void assert_core_router_exists(){ 
				coreRouter = (CoreRouter) this.routerManagementUseCase.
				createRouter(Vendor.CISCO, Model.XYZ0001, IP.fromAddress("30.0.0.1"), locationA, CORE);
				assertNotNull(coreRouter);
			}
			
			@Then("I add an edge router to a core router")
			public void add_edge_to_core_router(){
				var actualEdgeId = edgeRouter.getId();
				var routerWithEdge = (CoreRouter) this.routerManagementUseCase.
				addRouterToCoreRouter(edgeRouter, coreRouter);
				var expectedEdgeId = routerWithEdge.getRouters().get(actualEdgeId).getId();
				assertEquals(actualEdgeId,expectedEdgeId);
			}
		}
		```

08. 프레임워크 헥사곤 만들기
    헥사고날 애플리케이션을 만들 때 마지막 단계는 입력 포트에 입력 어댑터를 연결해 애플리케이션 기능을 노출하는 단계다. 그리고 외부 시스템에서 데이터를 가져오거나 유지해야 하는 경우 출력 어댑터를 출력 포트에 연결해야 한다. 프레임워크 헥사곤은 헥사고날 시스템을 만드는 데 필요한 모든 어댑터를 조립하는 곳이다. 
    
    여기서는 먼저 도메인 헥사곤에서 엔티티, 값 객체, 명세 등을 이용해 도메인 모델을 만든다. 그다음, 애플리케이션 헥사곤에서 유스케이스와 포트를 사용해 사용자의 의도를 표현한다. 이제 프레임워크 헥사곤에서는 시스템의 기능을 노출하고 이러한 기능을 활성화하는 데 사용할 기술을 노출하고 이러한 기능을 활성화하는 데 사용할 기술을 정의하기 위해 어댑터를 활용해야 한다.

	- 프레임워크 헥사곤 부트스트래핑
	  헥사고날 아키텍처를 사용해 시스템을 만들 때는 REST나 gRPC를 사용해 시스템 API를 노출할 것인 지, 아니면 시스템의 주된 데이터 소스가 MySQL 데이터베이스가 될지 MongoDB가 될지를 미리 결정할 필요가 없다. 그 대신 도메인 헥사곤에서 문제 영역의 모델링을 시작하고, 그다음 애플리케이션 헥사곤에서 유스케이스를 설계하고 구현해야 한다. 앞의 두 헥사곤을 만들고 나면 어떤 기술을 사용해 헥사고날 시스템 기능을 활성화할 것인지 생각해야 한다.

	- 출력 어댑터 구현
	  순서상 입력 어댑터의 구현시에 출력 어댑터를 참조하기 때문에 출력 아댑터의 구현이 우선 되어야 한다. 
		```java
	 import dev.davivieira.topologyinventory.domain.entity.Router
	 import dev.davivieira.topologyinventory.domain.vo.Id

	 public interface RouterManagementOutputPort{
		 Router retrieveRouter(Id id);
		 Router removeRouter(Id id);
		 Router persistRouter(Router router);
	 }
		```
	  위와 같이 선언된 Interface 와 관련된 구현은 아래와 같이 한다.

		```java
	 import dev.devivieira.topologyinventory.application.ports.output.RouterManagementOutputPort;
	 import dev.devivieira.topologyinventory.domain.entity.Router;
	 import dev.devivieira.topologyinventory.domain.vo.Id;
	 import dev.devivieira.topologyinventory.framework.adapters.output.h2.data.RouterData;
	 import dev.devivieira.topologyinventory.framework.adapters.output.h2.mappers.RouterH2Mapper;
	 import jakarta.persistence.EntityManager;
	 import jakarta.persistence.EntityManagerFactory;
	 import jakarta.persistence.Persistence;
	 import jakarta.persistence.PersistenceContext;
	 
	 public class RouterManagementH2Adapter implements RouterManagementOutputPort {
	 
		 private static RouterManagementH2Adapter instance;
		 
		 @PersistenceContet
		 private EntityManager em;
		 
		 private RouterManagementH2Adapter(){
			 setUpH2Database();
		 }
		 
		 @Override public Router retrieveRouter(Id id) {
			 var routerData = em.getReference(RouterData.class, id.getUuid());
			 return RouterH2Mapper.routerDataToDomain(routerData);
		 }
		 
		 @Override public Router removeRouter(Id id) {
			var routerData = em.getReference(RouterData.class, id.getUuid());
			em.remove(routerData);
			return null;
		 }
		 
		 @Override public Router persistRouter(Router router) {
			var routerData = RouterH2Mapper.routerDomainToData(router);
			em.persist(routerData);
			return router;
		 }
	 
	 }
	 
		```

	- 입력 어댑터 구현
	  애플리케이션 헥사곤을 만들 때 시스템 기능을 표현하기 위한 유스케이스와 입력 포트를 만들어야 한다. 이러한 기능을 사용자와 다른 시스템에서 사용할 수 있게 만들려면 입력 어댑터를 만들고 그것들을 입력 포트에 연결해야 한다.
		- 라우터 관리 입력 어댑터
		  아래와 같이 입력 어댑터 구현을 알아보도록 한다. 입력 어댑터는 입력 포트를 호출하는 Client의 역할을 수행한다. 
		  
		  ```java
		  public class RouterManagementGenericAdapter {
			private RouterManagementUseCase routerManagementUseCase;
			public RouterManagementGenericAdapter() {
				setPorts();
			}
			
			private void setPorts() {
				this.routerManagementUseCase = new RouterManagementInputPort(RouterManagementH2Adapter.getInstance())
			}
			
			/** * GET /router/retrieve/{id} * */ 
			public Router retrieveRouter(Id id){
				return routerManagementUseCase.retrieveRouter(id);
			}
			/** * GET /router/remove/{id} * */ 
			public Router removeRouter(Id id){
				return routerManagementUseCase.removeRouter(id);
			}
			
			/** * POST /router/create * */
			public Router createRouter(Vendor vendor, Model, IP, Location, RouterType routerType){ 
				var router = routerManagementUseCase.createRouter( null, vendor, model, ip, location, routerType);
				return routerManagementUseCase.persistRouter(router);
			}

		  }
			```

09. 자바 모듈을 이용한 의존성 역전 허용
    일단은 Gradle의 모듈을 이용해서 명시적으로 의존성을 설정해주고 이후에 JPMS로 모듈에 대한 명시적인 설정을 옮겨 오기로 한다.	  


## 3부 클라우드 네이티브로의 전환
- 3부의 내용은 Quarkus, Restful API 적용의 내용을 다루고 있으므로 예제로 대체하도록 한다.  